<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IIR滤波器信号流图对比</title>
    
    <!-- KaTeX CSS & JS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    <style>
        :root {
            --bg-color: #f0f2f5;
            --card-bg: #ffffff;
            --border-radius: 8px;
            --text-color: #333;
            --panel-spacing: 15px;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Microsoft YaHei", "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: var(--text-color);
            padding: 15px;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            font-size: 18px; 
            font-style: normal;
        }

        .main-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: var(--panel-spacing);
            max-width: 1900px;
            margin: 0 auto;
            width: 100%;
        }

        .panel {
            background: var(--card-bg);
            border-radius: var(--border-radius);
            box-shadow: 0 4px 16px rgba(0,0,0,0.15);
            padding: 12px 15px;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .panel-header {
            font-size: 1.3rem;
            font-weight: bold;
            margin-bottom: 8px;
            padding-bottom: 5px;
            border-bottom: 2px solid #eee;
            color: #222;
        }

        .top-row {
            display: flex;
            gap: var(--panel-spacing);
            height: 28%;
            min-height: 220px;
        }

        #panel-input { flex: 2.5; overflow: visible; }
        #panel-formula {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #fffbf0;
        }
        
        #hz-display { font-size: 1.2em; width: 100%; text-align: center; }

        .bottom-row {
            display: flex;
            gap: var(--panel-spacing);
            flex: 1;
            min-height: 300px;
        }

        .graph-panel { flex: 1; display: flex; flex-direction: column; }

        .order-settings {
            display: flex;
            gap: 40px;
            margin-bottom: 10px;
            align-items: center;
            background: #f8f9fa;
            padding: 8px;
            border-radius: 6px;
        }
        .order-control {
            display: flex;
            align-items: center;
            gap: 12px;
            font-weight: 600;
            font-size: 1.1rem;
        }
        .order-input {
            width: 70px;
            padding: 4px;
            border: 2px solid #ccc;
            border-radius: 6px;
            text-align: center;
            font-family: inherit;
            font-size: 1.2rem;
            font-weight: bold;
        }

        .equation-container {
            font-size: 1.5rem;
            line-height: 2.2;
            display: flex;
            flex-wrap: wrap;
            align-items: baseline;
            font-family: inherit;
            font-style: normal;
            padding-top: 5px;
        }
        
        .coeff-wrapper {
            display: inline-flex;
            align-items: center;
            margin: 0 2px;
            white-space: nowrap;
        }

        .coeff-input {
            width: 75px;
            padding: 2px 0;
            text-align: center;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-weight: bold;
            font-family: inherit;
            font-size: 1.3rem;
            margin: 0 6px;
            outline: none;
            background: rgba(255,255,255,0.9);
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.05);
        }
        .coeff-input:focus {
            transform: scale(1.05);
            border-color: #667eea;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.2);
        }
        
        .term-label { color: #222; font-style: normal; font-family: inherit; }
        .op-sign { margin: 0 6px; color: #444; font-weight: bold; font-family: inherit; }
        .eq-equals { margin: 0 15px; font-weight: bold; font-size: 1.6rem; font-family: inherit; }

        .svg-container { flex: 1; width: 100%; height: 100%; position: relative; overflow: hidden; }
        svg { width: 100%; height: 100%; display: block; }

        .io-text { font-size: 22px; font-weight: bold; font-family: inherit; fill: #000; font-style: normal; }
        .delay-text { font-size: 20px; text-anchor: middle; fill: #333; font-family: inherit; font-weight: bold; font-style: normal; }
        .coeff-text { font-weight: bold; font-size: 20px; text-anchor: middle; font-family: inherit; font-style: normal; }
        
        .katex { font-size: 1.6em !important; }

        @media (max-width: 1200px) {
            body { overflow: auto; height: auto; }
            .main-container { height: auto; display: block; }
            .top-row, .bottom-row { display: flex; flex-direction: column; height: auto; gap: 20px; margin-bottom: 20px;}
            .panel { min-height: 250px; }
            .equation-container { font-size: 1.2rem; }
        }
    </style>
</head>
<body>

<div class="main-container">

    <!-- 上半部分 -->
    <div class="top-row">
        
        <!-- 左上：参数设置 -->
        <div id="panel-input" class="panel">
            <div class="panel-header">差分方程设置 (Difference Equation)</div>
            
            <div class="order-settings">
                <div class="order-control">
                    <label>输入阶数 N (x):</label>
                    <input type="number" id="order-n" class="order-input" value="2" min="0" max="5">
                </div>
                <div class="order-control">
                    <label>输出阶数 M (y):</label>
                    <input type="number" id="order-m" class="order-input" value="2" min="0" max="5">
                </div>
            </div>

            <div id="diff-equation" class="equation-container">
                <!-- 动态生成 -->
            </div>
        </div>

        <!-- 右上：系统函数 -->
        <div id="panel-formula" class="panel">
            <div class="panel-header">系统传递函数 H(z)</div>
            <div id="hz-display">H(z) = ...</div>
        </div>

    </div>

    <!-- 下半部分 -->
    <div class="bottom-row">
        
        <!-- 左下：直接I型 -->
        <div id="panel-df1" class="panel graph-panel">
            <div class="panel-header">直接 I 型 (Direct Form I)</div>
            <div class="svg-container">
                <svg id="svg-df1" preserveAspectRatio="xMidYMid meet"></svg>
            </div>
        </div>

        <!-- 右下：直接II型 -->
        <div id="panel-df2" class="panel graph-panel">
            <div class="panel-header">直接 II 型 (Direct Form II)</div>
            <div class="svg-container">
                <svg id="svg-df2" preserveAspectRatio="xMidYMid meet"></svg>
            </div>
        </div>

    </div>

</div>

<script>
// --- 颜色定义（使用更明显的区分）---
const interpolateColor = (color1, color2, factor) => {
    const result = color1.slice();
    for (let i = 0; i < 3; i++) {
        result[i] = Math.round(result[i] + factor * (color2[i] - result[i]));
    }
    return `rgb(${result[0]}, ${result[1]}, ${result[2]})`;
};

// 使用蓝色系（输入x）和橙红色系（输出y）
const bColors = { start: [0, 120, 255], end: [0, 60, 150] }; 
const aColors = { start: [255, 140, 0], end: [200, 0, 0] }; 

function getBColor(i, totalN) {
    const factor = totalN > 0 ? i / totalN : 0;
    return interpolateColor(bColors.start, bColors.end, factor);
}

function getAColor(i, totalM) {
    if (i === 0) return 'rgb(220, 20, 60)'; // a[0]使用深红色
    const factor = totalM > 1 ? (i - 1) / (totalM - 1) : 0;
    return interpolateColor(aColors.start, aColors.end, factor);
}

// --- 状态管理 ---
let state = {
    N: 2,
    M: 2,
    b: [1, 1, 1],
    a: [1, 1, 1]
};

// DOM 元素
const dom = {
    nInput: document.getElementById('order-n'),
    mInput: document.getElementById('order-m'),
    eqContainer: document.getElementById('diff-equation'),
    hzDisplay: document.getElementById('hz-display'),
    svg1: document.getElementById('svg-df1'),
    svg2: document.getElementById('svg-df2')
};

/**
 * 解析输入框中的值，支持分数
 */
function parseCoeff(value) {
    const str = String(value).trim();
    if (str.includes('/')) {
        const parts = str.split('/');
        if (parts.length === 2) {
            const num = parseFloat(parts[0]);
            const den = parseFloat(parts[1]);
            if (!isNaN(num) && !isNaN(den) && den !== 0) {
                return num / den;
            }
        }
    }
    return parseFloat(str) || 0;
}

/**
 * 格式化显示系数，处理正负号
 */
function formatCoeffDisplay(value, isFirst = false) {
    if (value === 0) return { sign: '', coeff: '0' };
    
    if (isFirst) {
        return { sign: '', coeff: Math.abs(value).toString() };
    } else {
        const sign = value >= 0 ? '+' : '-';
        const coeff = Math.abs(value).toString();
        return { sign, coeff };
    }
}

// --- 逻辑核心 ---
function generateEquationInputs() {
    dom.eqContainer.innerHTML = '';

    const N = parseInt(dom.nInput.value) || 0;
    const M = parseInt(dom.mInput.value) || 0;
    
    while (state.b.length <= N) state.b.push(1);
    state.b = state.b.slice(0, N + 1);
    
    while (state.a.length <= M) state.a.push(1);
    state.a = state.a.slice(0, M + 1);
    
    state.N = N;
    state.M = M;

    // --- 左侧：y 项 ---
    // y[n] 的系数 a[0] (改为正常的第一项，不独立显示)
    for (let i = 0; i <= M; i++) {
        const wrapper = document.createElement('span');
        wrapper.className = 'coeff-wrapper';
        const color = getAColor(i, M);
        
        // 处理符号显示
        const { sign, coeff } = formatCoeffDisplay(state.a[i], i === 0);
        if (i > 0) {
            wrapper.innerHTML = `<span class="op-sign">${sign}</span>`;
        }
        
        const input = document.createElement('input');
        input.type = 'text';
        input.className = 'coeff-input';
        input.value = state.a[i];
        input.style.borderColor = color;
        input.style.color = color;
        input.oninput = (e) => {
            state.a[i] = parseCoeff(e.target.value);
            updateVisuals();
        };

        const term = i === 0 ? `y[n]` : `y[n-${i}]`;
        wrapper.appendChild(input);
        wrapper.insertAdjacentHTML('beforeend', `<span class="term-label">${term}</span>`);
        dom.eqContainer.appendChild(wrapper);
    }

    // --- 等号 ---
    const eqSign = document.createElement('span');
    eqSign.className = 'eq-equals';
    eqSign.textContent = '=';
    dom.eqContainer.appendChild(eqSign);

    // --- 右侧：x 项 ---
    for (let i = 0; i <= N; i++) {
        const wrapper = document.createElement('span');
        wrapper.className = 'coeff-wrapper';
        const color = getBColor(i, N);
        
        // 处理符号显示
        const { sign, coeff } = formatCoeffDisplay(state.b[i], i === 0);
        if (i > 0) {
            wrapper.innerHTML = `<span class="op-sign">${sign}</span>`;
        }

        const input = document.createElement('input');
        input.type = 'text';
        input.className = 'coeff-input';
        input.value = state.b[i];
        input.style.borderColor = color;
        input.style.color = color;
        input.oninput = (e) => {
            state.b[i] = parseCoeff(e.target.value);
            updateVisuals();
        };

        const term = i === 0 ? `x[n]` : `x[n-${i}]`;
        
        wrapper.appendChild(input);
        wrapper.insertAdjacentHTML('beforeend', `<span class="term-label">${term}</span>`);
        dom.eqContainer.appendChild(wrapper);
    }
    
    updateVisuals();
}

function updateVisuals() {
    renderFormula();
    drawDirectFormI();
    drawDirectFormII();
}

/**
 * H(z) 公式渲染
 */
function renderFormula() {
    const formatCoeff = (c) => Math.round(c * 1000) / 1000;

    // 分子 (b) - 不除以a[0]，直接使用原始系数
    const bTerms = state.b.map((c, i) => {
        if (c === 0) return null;
        const sign = c > 0 ? (i > 0 ? '+' : '') : ''; 
        const z = i === 0 ? '' : (i === 1 ? 'z^{-1}' : `z^{-${i}}`);
        return `${sign}${formatCoeff(c)}${z}`;
    }).filter(t => t !== null).join(' ');
    
    // 分母 (a) - 不除以a[0]，直接使用原始系数
    const aTerms = state.a.map((c, i) => {
        if (c === 0) return null;
        const sign = c > 0 ? (i > 0 ? '+' : '') : ''; 
        const z = i === 0 ? '' : (i === 1 ? 'z^{-1}' : `z^{-${i}}`);
        return `${sign}${formatCoeff(c)}${z}`;
    }).filter(t => t !== null).join(' ');

    const num = bTerms || '0';
    const den = aTerms || '1';

    dom.hzDisplay.innerHTML = `$$ H(z) = \\frac{Y(z)}{X(z)} = \\frac{${num}}{${den}} $$`;
    
    // 延迟渲染以确保KaTeX加载完成
    if (window.renderMathInElement) {
        setTimeout(() => {
            renderMathInElement(dom.hzDisplay, {
                delimiters: [{left: "$$", right: "$$", display: true}],
                throwOnError: false
            });
        }, 100);
    }
}

// --- SVG 绘制助手 ---
const SVG_NS = "http://www.w3.org/2000/svg";
function createEl(type, attrs) {
    const e = document.createElementNS(SVG_NS, type);
    for (const k in attrs) e.setAttribute(k, attrs[k]);
    return e;
}

/**
 * 绘制箭头
 */
function drawArrow(svg, x1, y1, x2, y2, color="#333", width=2.5) {
    const dx = x2 - x1;
    const dy = y2 - y1;
    const len = Math.sqrt(dx*dx + dy*dy);
    if (len < 1) return;
    
    const angle = Math.atan2(dy, dx) * 180 / Math.PI;
    const arrowSize = 12;
    
    // 箭头位置在终点
    const arrowX = x2;
    const arrowY = y2;
    
    svg.appendChild(createEl('line', { x1, y1, x2, y2, stroke: color, "stroke-width": width }));
    svg.appendChild(createEl('path', {
        d: `M 0 0 L ${-arrowSize} ${-arrowSize/2.5} L ${-arrowSize} ${arrowSize/2.5} z`,
        fill: color,
        transform: `translate(${arrowX}, ${arrowY}) rotate(${angle})`
    }));
}

/**
 * 绘制节点（实心圆点）
 */
function drawNode(svg, cx, cy, r=6) {
    svg.appendChild(createEl('circle', { cx, cy, r, fill: '#222', stroke: '#222', 'stroke-width': 1 }));
}

/**
 * 绘制延迟标签（在箭头上）
 */
function drawDelayLabel(svg, x, y, text='z⁻¹') {
    const txt = createEl('text', { x, y: y+6, class: 'delay-text' });
    txt.textContent = text;
    svg.appendChild(txt);
}

// --- 结构图绘制 ---
function drawDirectFormI() {
    const svg = dom.svg1;
    svg.innerHTML = '';
    const a0 = state.a[0] || 1;
    const maxOrder = Math.max(state.N, state.M, 1);
    
    const V_SPACING = 90, TOP_MARGIN = 60, WIDTH = 800;
    const HEIGHT = TOP_MARGIN + maxOrder * V_SPACING + 50;
    svg.setAttribute('viewBox', `0 0 ${WIDTH} ${HEIGHT}`);

    const x_in = 60, x_delay_L = 220, x_sum_L = 320, x_sum_R = 460, x_delay_R = 560, x_out = 720;

    // 输入
    drawArrow(svg, x_in, TOP_MARGIN, x_delay_L, TOP_MARGIN);
    svg.appendChild(createEl('text', { x: x_in, y: TOP_MARGIN-15, class: 'io-text' })).textContent = 'x[n]';

    // 左侧延迟链（x）
    for (let i=0; i<state.N; i++) {
        const y1 = TOP_MARGIN + i*V_SPACING, y2 = TOP_MARGIN + (i+1)*V_SPACING;
        drawArrow(svg, x_delay_L, y1, x_delay_L, y2);
        drawDelayLabel(svg, x_delay_L + 20, y1 + V_SPACING/2);
    }
    
    // 左侧求和节点
    drawNode(svg, x_sum_L, TOP_MARGIN);

    // 前馈路径（b系数）
    for (let i=0; i<=state.N; i++) {
        const y = TOP_MARGIN + i*V_SPACING;
        const color = getBColor(i, state.N);
        drawNode(svg, x_delay_L, y);
        
        if (i === 0) {
            drawArrow(svg, x_delay_L, y, x_sum_L, y, color, 2.5);
        } else {
            svg.appendChild(createEl('polyline', { 
                points: `${x_delay_L},${y} ${x_sum_L},${y} ${x_sum_L},${TOP_MARGIN+8}`, 
                fill: 'none', 
                stroke: color, 
                "stroke-width": 2.5 
            }));
            drawArrow(svg, x_delay_L, y, (x_delay_L+x_sum_L)/2, y, color, 2.5); 
        }
        // 不除以a[0]，直接使用原始系数
        const val = Math.round(state.b[i] * 1000) / 1000;
        const txt = createEl('text', {x: (x_delay_L+x_sum_L)/2, y: y-12, class:'coeff-text', fill: color});
        txt.textContent = val;
        svg.appendChild(txt);
    }

    // 中间信号
    drawArrow(svg, x_sum_L, TOP_MARGIN, x_sum_R, TOP_MARGIN);

    // 右侧求和节点
    drawNode(svg, x_sum_R, TOP_MARGIN);
    
    // 输出
    drawArrow(svg, x_sum_R, TOP_MARGIN, x_out, TOP_MARGIN); 
    drawArrow(svg, x_sum_R, TOP_MARGIN, x_delay_R, TOP_MARGIN); 
    svg.appendChild(createEl('text', { x: x_out-10, y: TOP_MARGIN-15, class: 'io-text' })).textContent = 'y[n]';

    // 右侧延迟链（y）
    for (let i=0; i<state.M; i++) {
        const y1 = TOP_MARGIN + i*V_SPACING, y2 = TOP_MARGIN + (i+1)*V_SPACING;
        drawArrow(svg, x_delay_R, y1, x_delay_R, y2);
        drawDelayLabel(svg, x_delay_R + 20, y1 + V_SPACING/2);
    }

    // 显示a[0]系数（在反馈系数组上方）
    const a0Color = getAColor(0, state.M);
    // 不除以a[0]，直接使用原始系数
    const a0Val = Math.round(state.a[0] * 1000) / 1000;
    if (state.M >= 1) {
        // 当有反馈路径时，显示在第一个反馈系数上方
        const a0Y = TOP_MARGIN + V_SPACING - 100;
        const a0txt = createEl('text', {x: (x_delay_R+x_sum_R)/2, y: a0Y, class:'coeff-text', fill: a0Color});
        a0txt.textContent = a0Val;
        svg.appendChild(a0txt);
    } else {
        // 当没有反馈路径时，显示在适当位置
        const a0txt = createEl('text', {x: (x_delay_R+x_sum_R)/2, y: TOP_MARGIN + 35, class:'coeff-text', fill: a0Color});
        a0txt.textContent = a0Val;
        svg.appendChild(a0txt);
    }
    
    // 反馈路径（-a系数）
    for (let i=1; i<=state.M; i++) {
        const y = TOP_MARGIN + i*V_SPACING;
        const color = getAColor(i, state.M);
        drawNode(svg, x_delay_R, y);
        
        svg.appendChild(createEl('polyline', { 
            points: `${x_delay_R},${y} ${x_sum_R},${y} ${x_sum_R},${TOP_MARGIN+8}`, 
            fill: 'none', 
            stroke: color, 
            "stroke-width": 2.5 
        }));
        drawArrow(svg, x_delay_R, y, (x_delay_R+x_sum_R)/2, y, color, 2.5);
        
        // 不除以a[0]，直接使用原始系数的负值
        const val = Math.round(-state.a[i] * 1000) / 1000;
        const txt = createEl('text', {x: (x_delay_R+x_sum_R)/2, y: y-12, class:'coeff-text', fill: color});
        txt.textContent = val;
        svg.appendChild(txt);
    }
}

function drawDirectFormII() {
    const svg = dom.svg2;
    svg.innerHTML = '';
    const a0 = state.a[0];
    const maxOrder = Math.max(state.N, state.M, 1);
    
    const V_SPACING = 90, TOP_MARGIN = 60, WIDTH = 800;
    const HEIGHT = TOP_MARGIN + maxOrder * V_SPACING + 50;
    svg.setAttribute('viewBox', `0 0 ${WIDTH} ${HEIGHT}`);

    const centerX = WIDTH / 2;
    const wingSpan = 160; 
    const leftSumX = centerX - wingSpan;
    const rightSumX = centerX + wingSpan;

    // 输入
    drawArrow(svg, 60, TOP_MARGIN, leftSumX, TOP_MARGIN);
    svg.appendChild(createEl('text', { x: 60, y: TOP_MARGIN-15, class: 'io-text' })).textContent = 'x[n]';

    // 左侧求和节点
    drawNode(svg, leftSumX, TOP_MARGIN);
    
    // 中间连接
    drawArrow(svg, leftSumX, TOP_MARGIN, centerX, TOP_MARGIN);

    // 中间延迟链
    for (let i=0; i<maxOrder; i++) {
        const y1 = TOP_MARGIN + i*V_SPACING, y2 = TOP_MARGIN + (i+1)*V_SPACING;
        drawArrow(svg, centerX, y1, centerX, y2);
        drawDelayLabel(svg, centerX + 20, y1 + V_SPACING/2);
    }

    // 右侧求和节点
    drawNode(svg, rightSumX, TOP_MARGIN);
    
    // 输出
    drawArrow(svg, rightSumX, TOP_MARGIN, WIDTH-60, TOP_MARGIN);
    svg.appendChild(createEl('text', { x: WIDTH-80, y: TOP_MARGIN-15, class: 'io-text' })).textContent = 'y[n]';
    
    // 显示a[0]系数（在左侧反馈系数组上方）
    const a0Color = getAColor(0, state.M);
    const a0Val = Math.round(a0 * 1000) / 1000;
    if (state.M >= 1) {
        // 当有反馈路径时，显示在第一个反馈系数上方
        const a0Y = TOP_MARGIN + V_SPACING - 100;
        const a0txt = createEl('text', {x: centerX - wingSpan/2, y: a0Y, class:'coeff-text', fill: a0Color});
        a0txt.textContent = a0Val;
        svg.appendChild(a0txt);
    } else {
        // 当没有反馈路径时，显示在适当位置
        const a0txt = createEl('text', {x: centerX - wingSpan/2, y: TOP_MARGIN + 35, class:'coeff-text', fill: a0Color});
        a0txt.textContent = a0Val;
        svg.appendChild(a0txt);
    }

    // 左翼反馈路径
    for (let i=1; i<=state.M; i++) {
        const y = TOP_MARGIN + i*V_SPACING;
        const color = getAColor(i, state.M);
        drawNode(svg, centerX, y);
        
        svg.appendChild(createEl('polyline', { 
            points: `${centerX},${y} ${leftSumX},${y} ${leftSumX},${TOP_MARGIN+8}`, 
            fill: 'none', 
            stroke: color, 
            "stroke-width": 2.5 
        }));
        drawArrow(svg, centerX, y, (centerX+leftSumX)/2, y, color, 2.5);
        
        // 反馈系数：不除以a[0]，直接取反
        const val = Math.round(-state.a[i] * 1000) / 1000;
        const txt = createEl('text', {x: centerX - wingSpan/2, y: y-12, class:'coeff-text', fill: color});
        txt.textContent = val;
        svg.appendChild(txt);
    }

    // 右翼前馈路径
    for (let i=0; i<=state.N; i++) {
        const y = TOP_MARGIN + i*V_SPACING;
        const color = getBColor(i, state.N);
        drawNode(svg, centerX, y);
        
        if (i === 0) {
            drawArrow(svg, centerX, y, rightSumX, y, color, 2.5);
        } else {
            svg.appendChild(createEl('polyline', { 
                points: `${centerX},${y} ${rightSumX},${y} ${rightSumX},${TOP_MARGIN+8}`, 
                fill: 'none', 
                stroke: color, 
                "stroke-width": 2.5 
            }));
            drawArrow(svg, centerX, y, (centerX+rightSumX)/2, y, color, 2.5);
        }
        
        // 前馈系数：不除以a[0]
        const val = Math.round(state.b[i] * 1000) / 1000;
        const txt = createEl('text', {x: centerX + wingSpan/2, y: y-12, class:'coeff-text', fill: color});
        txt.textContent = val;
        svg.appendChild(txt);
    }
}

// --- 事件监听与初始化 ---
dom.nInput.addEventListener('change', generateEquationInputs);
dom.mInput.addEventListener('change', generateEquationInputs);

// 优化的初始化：确保KaTeX完全加载
let initAttempts = 0;
function tryInitialize() {
    if (window.renderMathInElement || initAttempts > 50) {
        generateEquationInputs();
    } else {
        initAttempts++;
        setTimeout(tryInitialize, 100);
    }
}

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', tryInitialize);
} else {
    tryInitialize();
}

</script>
</body>
</html>
