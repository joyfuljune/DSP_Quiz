<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IIR滤波器结构对比展示</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            min-height: 100vh;
            color: #333;
        }
        .main-container {
            max-width: 1600px;
            margin: 0 auto;
        }
        .header {
            text-align: center;
            color: white;
            margin-bottom: 40px;
        }
        .header h1 {
            font-size: 2.8em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        .header .subtitle {
            font-size: 1.3em;
            opacity: 0.95;
            margin-bottom: 10px;
        }
        .header .description {
            font-size: 1.1em;
            opacity: 0.9;
            max-width: 800px;
            margin: 0 auto;
        }
        
        .hz-display {
            background: rgba(255, 255, 255, 0.95);
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.2);
            margin-bottom: 30px;
            text-align: center;
        }
        .hz-display h2 {
            margin-bottom: 20px;
            font-size: 1.5em;
        }
        .hz-formula {
            font-size: 1.3em;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #667eea;
            display: inline-block;
        }
        
        .structures-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(600px, 1fr));
            gap: 25px;
            margin-bottom: 30px;
        }
        
        .cascade-parallel-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 25px;
        }
        
        .cascade-column {
            display: flex;
            flex-direction: column;
            gap: 25px;
        }
        
        .parallel-column {
            display: flex;
            flex-direction: column;
        }
        
        .structure-card {
            background: white;
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.2);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            display: flex;
            flex-direction: column;
        }
        .structure-card:hover {
            transform: translateY(-8px);
            box-shadow: 0 12px 32px rgba(0,0,0,0.25);
        }
        .structure-card h2 {
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 3px solid #667eea;
            font-size: 1.4em;
        }
        
        .decomposition-content {
            font-size: 1.05em;
            line-height: 1.8;
            color: #555;
            margin-bottom: 20px;
        }
        .decomposition-content h3 {
            color: #667eea;
            margin-top: 15px;
            margin-bottom: 10px;
            font-size: 1.2em;
        }
        .decomposition-content p {
            margin-bottom: 10px;
        }

        .flow-graph-svg {
            width: 100%;
            border: 1px solid #e0e0e0;
            background-color: #fdfdfd;
            border-radius: 8px;
            overflow: visible;
            margin-top: auto;
        }
        
        /* SVG Element Styles */
        .coeff-text { font-weight: bold; font-size: 20px; text-anchor: middle; font-family: inherit; font-style: normal; }
        .delay-text { font-size: 20px; text-anchor: middle; fill: #333; font-family: inherit; font-weight: bold; font-style: normal; }
        .io-text { font-size: 22px; font-weight: bold; font-family: inherit; fill: #000; font-style: normal; }
        
        @media (max-width: 1280px) {
            .structures-grid {
                grid-template-columns: 1fr;
            }
            .cascade-parallel-grid {
                grid-template-columns: 1fr;
            }
            .cascade-column, .parallel-column {
                width: 100%;
            }
        }
    </style>
</head>
<body>

<div class="main-container">
    <header class="header">
        <h1>IIR滤波器结构对比</h1>
        <div class="subtitle">直接I型 · 直接II型 · 级联型(4种配对) · 并联型</div>
        <p class="description">
            同一个传递函数可以通过不同的结构来实现。本页展示了一个二阶IIR滤波器的多种实现结构，包括详细的数学分解步骤。级联型展示了两个零点和两个极点的所有4种配对方式。
        </p>
    </header>

    <!-- 传递函数显示 -->
    <section class="hz-display">
        <h2>系统传递函数 H(z)</h2>
        <div id="hz-formula" class="hz-formula"></div>
    </section>

    <!-- 统一网格布局：直接I型和直接II型 -->
    <main class="structures-grid">

        <!-- 直接I型 -->
        <article class="structure-card">
            <h2>直接I型 (Direct Form I)</h2>
            <svg id="flow-graph-I" class="flow-graph-svg"></svg>
        </article>

        <!-- 直接II型 -->
        <article class="structure-card">
            <h2>直接II型 (Direct Form II)</h2>
            <svg id="flow-graph-II" class="flow-graph-svg"></svg>
        </article>

    </main>

    <!-- 级联型和并联型：2列布局 -->
    <section class="cascade-parallel-grid">
        
        <!-- 左侧：级联型所有配对 -->
        <div class="cascade-column">
            
            <article class="structure-card">
                <h2>级联型 (Cascade Form) - 数学分解</h2>
                <div class="decomposition-content">
                    <h3>分解步骤</h3>
                    <p><strong>1. 分解分子（零点）：</strong></p>
                    $$ B(z) = 1 + 1.5z^{-1} + 0.5z^{-2} = (1 + z^{-1})(1 + 0.5z^{-1}) $$
                    <p><strong>2. 分解分母（极点）：</strong></p>
                    $$ A(z) = 1 - 0.7z^{-1} + 0.1z^{-2} = (1 - 0.5z^{-1})(1 - 0.2z^{-1}) $$
                    <p><strong>3. 零极点配对：</strong></p>
                    <p>两个零点 {-1, -0.5} 和两个极点 {0.5, 0.2} 可以有 2×2 = 4 种配对方式：</p>
                    $$ H(z) = H_1(z) \cdot H_2(z) $$
                </div>
            </article>

            <!-- 配对1 -->
            <article class="structure-card">
                <h2>配对方式1</h2>
                <div class="decomposition-content">
                    $$ H(z) = \underbrace{\frac{1 + z^{-1}}{1 - 0.5z^{-1}}}_{H_1(z)} \cdot \underbrace{\frac{1 + 0.5z^{-1}}{1 - 0.2z^{-1}}}_{H_2(z)} $$
                </div>
                <svg id="flow-graph-cascade1" class="flow-graph-svg"></svg>
            </article>

            <!-- 配对2 -->
            <article class="structure-card">
                <h2>配对方式2</h2>
                <div class="decomposition-content">
                    $$ H(z) = \underbrace{\frac{1 + z^{-1}}{1 - 0.2z^{-1}}}_{H_1(z)} \cdot \underbrace{\frac{1 + 0.5z^{-1}}{1 - 0.5z^{-1}}}_{H_2(z)} $$
                </div>
                <svg id="flow-graph-cascade2" class="flow-graph-svg"></svg>
            </article>

            <!-- 配对3 -->
            <article class="structure-card">
                <h2>配对方式3</h2>
                <div class="decomposition-content">
                    $$ H(z) = \underbrace{\frac{1 + 0.5z^{-1}}{1 - 0.5z^{-1}}}_{H_1(z)} \cdot \underbrace{\frac{1 + z^{-1}}{1 - 0.2z^{-1}}}_{H_2(z)} $$
                </div>
                <svg id="flow-graph-cascade3" class="flow-graph-svg"></svg>
            </article>

            <!-- 配对4 -->
            <article class="structure-card">
                <h2>配对方式4</h2>
                <div class="decomposition-content">
                    $$ H(z) = \underbrace{\frac{1 + 0.5z^{-1}}{1 - 0.2z^{-1}}}_{H_1(z)} \cdot \underbrace{\frac{1 + z^{-1}}{1 - 0.5z^{-1}}}_{H_2(z)} $$
                </div>
                <svg id="flow-graph-cascade4" class="flow-graph-svg"></svg>
            </article>

        </div>

        <!-- 右侧：并联型 -->
        <div class="parallel-column">
            
            <article class="structure-card">
                <h2>并联型 (Parallel Form)</h2>
                <div class="decomposition-content">
                    <h3>部分分式展开步骤</h3>
                    <p><strong>原始传递函数：</strong></p>
                    $$ H(z) = \frac{1 + 1.5z^{-1} + 0.5z^{-2}}{1 - 0.7z^{-1} + 0.1z^{-2}} $$
                    
                    <p><strong>1. 提取常数项（分子分母同阶）：</strong></p>
                    $$ C_0 = \lim_{z \to \infty} H(z) = \frac{b_2}{a_2} = \frac{0.5}{0.1} = 5 $$
                    
                    <p><strong>2. 计算余项：</strong></p>
                    $$ H(z) - C_0 = \frac{1 + 1.5z^{-1} + 0.5z^{-2}}{1 - 0.7z^{-1} + 0.1z^{-2}} - 5 $$
                    $$ = \frac{1 + 1.5z^{-1} + 0.5z^{-2} - 5(1 - 0.7z^{-1} + 0.1z^{-2})}{1 - 0.7z^{-1} + 0.1z^{-2}} $$
                    $$ = \frac{-4 + 5z^{-1}}{1 - 0.7z^{-1} + 0.1z^{-2}} $$
                    
                    <p><strong>3. 对余项进行部分分式展开：</strong></p>
                    <p>分母因式分解：$$ 1 - 0.7z^{-1} + 0.1z^{-2} = (1 - 0.5z^{-1})(1 - 0.2z^{-1}) $$</p>
                    $$ \frac{-4 + 5z^{-1}}{(1 - 0.5z^{-1})(1 - 0.2z^{-1})} = \frac{A}{1 - 0.5z^{-1}} + \frac{B}{1 - 0.2z^{-1}} $$
                    
                    <p><strong>4. 求系数A和B：</strong></p>
                    <p>令 $$ z^{-1} = 2 $$（极点 0.5）：$$ A = \frac{-4 + 5(2)}{1 - 0.2(2)} = \frac{6}{0.6} = 10 $$</p>
                    <p>令 $$ z^{-1} = 5 $$（极点 0.2）：$$ B = \frac{-4 + 5(5)}{1 - 0.5(5)} = \frac{21}{-1.5} = -14 $$</p>
                    
                    <p><strong>5. 最终并联形式：</strong></p>
                    $$ H(z) = 5 + \frac{10}{1 - 0.5z^{-1}} + \frac{-14}{1 - 0.2z^{-1}} $$
                </div>
                <svg id="flow-graph-parallel" class="flow-graph-svg"></svg>
            </article>

        </div>

    </section>
</div>

<script>
const SVG_NS = "http://www.w3.org/2000/svg";

document.addEventListener('DOMContentLoaded', () => {
    // 系数定义
    const COEFFS = {
        b: [1, 1.5, 0.5],
        a: [1, -0.7, 0.1]
    };

    const interpolateColor = (color1, color2, factor) => {
        const result = color1.slice();
        for (let i = 0; i < 3; i++) {
            result[i] = Math.round(result[i] + factor * (color2[i] - result[i]));
        }
        return `rgb(${result[0]}, ${result[1]}, ${result[2]})`;
    };
    
    const bColors = { start: [0, 120, 255], end: [0, 60, 150] }; 
    const aColors = { start: [255, 140, 0], end: [200, 0, 0] };

    function getBColor(i, totalN) {
        const factor = totalN > 0 ? i / totalN : 0;
        return interpolateColor(bColors.start, bColors.end, factor);
    }

    function getAColor(i, totalM) {
        const factor = totalM > 1 ? (i - 1) / (totalM - 1) : 0;
        return interpolateColor(aColors.start, aColors.end, factor);
    }

    // SVG辅助函数
    function createEl(type, attrs) {
        const e = document.createElementNS(SVG_NS, type);
        for (const k in attrs) e.setAttribute(k, attrs[k]);
        return e;
    }

    function drawArrow(svg, x1, y1, x2, y2, color="#333", width=2.5) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        const len = Math.sqrt(dx*dx + dy*dy);
        if (len < 1) return;
        
        const angle = Math.atan2(dy, dx) * 180 / Math.PI;
        const arrowSize = 12;
        const arrowX = x2;
        const arrowY = y2;
        
        svg.appendChild(createEl('line', { x1, y1, x2, y2, stroke: color, "stroke-width": width }));
        svg.appendChild(createEl('path', {
            d: `M 0 0 L ${-arrowSize} ${-arrowSize/2.5} L ${-arrowSize} ${arrowSize/2.5} z`,
            fill: color,
            transform: `translate(${arrowX}, ${arrowY}) rotate(${angle})`
        }));
    }

    function drawNode(svg, cx, cy, r=6) {
        svg.appendChild(createEl('circle', { cx, cy, r, fill: '#222', stroke: '#222', 'stroke-width': 1 }));
    }

    function drawDelayLabel(svg, x, y, text='z⁻¹') {
        const txt = createEl('text', { x, y: y+6, class: 'delay-text' });
        txt.textContent = text;
        svg.appendChild(txt);
    }

    // 显示传递函数
    const displayHz = () => {
        const numTerms = COEFFS.b.map((c, i) => `${c >= 0 ? (i>0 ? '+' : '') : ''}${c}${i > 0 ? `z^{-${i}}` : ''}`).join(' ');
        const denTerms = COEFFS.a.slice(1).map((c, i) => `${c >= 0 ? '+' : ''}${c}z^{-${i+1}}`).join(' ');
        
        document.getElementById('hz-formula').innerHTML = `$$ H(z) = \\frac{${numTerms}}{1 ${denTerms}} $$`;
        
        if (window.renderMathInElement) {
            renderMathInElement(document.body);
        }
    };

    // 绘制直接I型
    const drawDirectFormI = () => {
        const svg = document.getElementById('flow-graph-I');
        svg.innerHTML = '';
        
        const N = 2, M = 2;
        const V_SPACING = 90, TOP_MARGIN = 60, WIDTH = 800;
        const HEIGHT = TOP_MARGIN + Math.max(N, M) * V_SPACING + 50;
        svg.setAttribute('viewBox', `0 0 ${WIDTH} ${HEIGHT}`);

        const x_in = 60, x_delay_L = 220, x_sum_L = 320, x_sum_R = 460, x_delay_R = 560, x_out = 720;

        // 输入
        drawArrow(svg, x_in, TOP_MARGIN, x_delay_L, TOP_MARGIN);
        svg.appendChild(createEl('text', { x: x_in, y: TOP_MARGIN-15, class: 'io-text' })).textContent = 'x[n]';

        // 左侧延迟链（x）
        for (let i=0; i<N; i++) {
            const y1 = TOP_MARGIN + i*V_SPACING, y2 = TOP_MARGIN + (i+1)*V_SPACING;
            drawArrow(svg, x_delay_L, y1, x_delay_L, y2);
            drawDelayLabel(svg, x_delay_L + 20, y1 + V_SPACING/2);
        }
        
        // 左侧求和节点
        drawNode(svg, x_sum_L, TOP_MARGIN);

        // 前馈路径（b系数）
        for (let i=0; i<=N; i++) {
            const y = TOP_MARGIN + i*V_SPACING;
            const color = getBColor(i, N);
            drawNode(svg, x_delay_L, y);
            
            if (i === 0) {
                drawArrow(svg, x_delay_L, y, x_sum_L, y, color, 2.5);
            } else {
                svg.appendChild(createEl('polyline', { 
                    points: `${x_delay_L},${y} ${x_sum_L},${y} ${x_sum_L},${TOP_MARGIN+8}`, 
                    fill: 'none', 
                    stroke: color, 
                    "stroke-width": 2.5 
                }));
                drawArrow(svg, x_delay_L, y, (x_delay_L+x_sum_L)/2, y, color, 2.5); 
            }
            const val = COEFFS.b[i];
            const txt = createEl('text', {x: (x_delay_L+x_sum_L)/2, y: y-12, class:'coeff-text', fill: color});
            txt.textContent = val;
            svg.appendChild(txt);
        }

        // 中间连接 - 删除w[n]标签
        drawArrow(svg, x_sum_L, TOP_MARGIN, x_sum_R, TOP_MARGIN);

        // 右侧求和节点
        drawNode(svg, x_sum_R, TOP_MARGIN);
        
        // 输出
        drawArrow(svg, x_sum_R, TOP_MARGIN, x_out, TOP_MARGIN); 
        drawArrow(svg, x_sum_R, TOP_MARGIN, x_delay_R, TOP_MARGIN); 
        svg.appendChild(createEl('text', { x: x_out-10, y: TOP_MARGIN-15, class: 'io-text' })).textContent = 'y[n]';

        // 右侧延迟链（y）
        for (let i=0; i<M; i++) {
            const y1 = TOP_MARGIN + i*V_SPACING, y2 = TOP_MARGIN + (i+1)*V_SPACING;
            drawArrow(svg, x_delay_R, y1, x_delay_R, y2);
            drawDelayLabel(svg, x_delay_R + 20, y1 + V_SPACING/2);
        }

        // 反馈路径（-a系数）
        for (let i=1; i<=M; i++) {
            const y = TOP_MARGIN + i*V_SPACING;
            const color = getAColor(i, M);
            drawNode(svg, x_delay_R, y);
            
            svg.appendChild(createEl('polyline', { 
                points: `${x_delay_R},${y} ${x_sum_R},${y} ${x_sum_R},${TOP_MARGIN+8}`, 
                fill: 'none', 
                stroke: color, 
                "stroke-width": 2.5 
            }));
            drawArrow(svg, x_delay_R, y, (x_delay_R+x_sum_R)/2, y, color, 2.5);
            
            const val = -COEFFS.a[i];
            const txt = createEl('text', {x: (x_delay_R+x_sum_R)/2, y: y-12, class:'coeff-text', fill: color});
            txt.textContent = val;
            svg.appendChild(txt);
        }
    };

    // 绘制直接II型
    const drawDirectFormII = () => {
        const svg = document.getElementById('flow-graph-II');
        svg.innerHTML = '';
        
        const N = 2, M = 2;
        const V_SPACING = 90, TOP_MARGIN = 60, WIDTH = 800;
        const maxOrder = Math.max(N, M);
        const HEIGHT = TOP_MARGIN + maxOrder * V_SPACING + 50;
        svg.setAttribute('viewBox', `0 0 ${WIDTH} ${HEIGHT}`);

        const centerX = WIDTH / 2;
        const wingSpan = 160; 
        const leftSumX = centerX - wingSpan;
        const rightSumX = centerX + wingSpan;

        // 输入
        drawArrow(svg, 60, TOP_MARGIN, leftSumX, TOP_MARGIN);
        svg.appendChild(createEl('text', { x: 60, y: TOP_MARGIN-15, class: 'io-text' })).textContent = 'x[n]';

        // 左侧求和节点
        drawNode(svg, leftSumX, TOP_MARGIN);
        
        // 中间连接 - 删除w[n]标签
        drawArrow(svg, leftSumX, TOP_MARGIN, centerX, TOP_MARGIN);

        // 中间延迟链
        for (let i=0; i<maxOrder; i++) {
            const y1 = TOP_MARGIN + i*V_SPACING, y2 = TOP_MARGIN + (i+1)*V_SPACING;
            drawArrow(svg, centerX, y1, centerX, y2);
            drawDelayLabel(svg, centerX + 20, y1 + V_SPACING/2);
        }

        // 右侧求和节点
        drawNode(svg, rightSumX, TOP_MARGIN);
        
        // 输出
        drawArrow(svg, rightSumX, TOP_MARGIN, WIDTH-60, TOP_MARGIN);
        svg.appendChild(createEl('text', { x: WIDTH-80, y: TOP_MARGIN-15, class: 'io-text' })).textContent = 'y[n]';

        // 左翼反馈路径
        for (let i=1; i<=M; i++) {
            const y = TOP_MARGIN + i*V_SPACING;
            const color = getAColor(i, M);
            drawNode(svg, centerX, y);
            
            svg.appendChild(createEl('polyline', { 
                points: `${centerX},${y} ${leftSumX},${y} ${leftSumX},${TOP_MARGIN+8}`, 
                fill: 'none', 
                stroke: color, 
                "stroke-width": 2.5 
            }));
            drawArrow(svg, centerX, y, (centerX+leftSumX)/2, y, color, 2.5);
            
            const val = -COEFFS.a[i];
            const txt = createEl('text', {x: centerX - wingSpan/2, y: y-12, class:'coeff-text', fill: color});
            txt.textContent = val;
            svg.appendChild(txt);
        }

        // 右翼前馈路径
        for (let i=0; i<=N; i++) {
            const y = TOP_MARGIN + i*V_SPACING;
            const color = getBColor(i, N);
            drawNode(svg, centerX, y);
            
            if (i === 0) {
                drawArrow(svg, centerX, y, rightSumX, y, color, 2.5);
            } else {
                svg.appendChild(createEl('polyline', { 
                    points: `${centerX},${y} ${rightSumX},${y} ${rightSumX},${TOP_MARGIN+8}`, 
                    fill: 'none', 
                    stroke: color, 
                    "stroke-width": 2.5 
                }));
                drawArrow(svg, centerX, y, (centerX+rightSumX)/2, y, color, 2.5);
            }
            
            const val = COEFFS.b[i];
            const txt = createEl('text', {x: centerX + wingSpan/2, y: y-12, class:'coeff-text', fill: color});
            txt.textContent = val;
            svg.appendChild(txt);
        }
    };

    // 绘制一阶节（级联型用）
    const drawFirstOrderSection = (svg, x_offset, y_offset, b0, b1, a1) => {
        const V_SPACING = 60, summer_offset = 70;
        const centerX = x_offset + summer_offset;
        const leftSumX = x_offset;
        const rightSumX = x_offset + 2 * summer_offset;

        // 左侧求和节点
        drawNode(svg, leftSumX, y_offset);
        drawArrow(svg, leftSumX, y_offset, centerX, y_offset);

        // 延迟单元
        drawArrow(svg, centerX, y_offset, centerX, y_offset + V_SPACING);
        drawNode(svg, centerX, y_offset);
        drawDelayLabel(svg, centerX + 15, y_offset + V_SPACING/2);

        // 反馈路径
        const color_a = aColors.start;
        const aColor = `rgb(${color_a.join()})`;
        svg.appendChild(createEl('polyline', { 
            points: `${centerX},${y_offset + V_SPACING} ${leftSumX},${y_offset + V_SPACING} ${leftSumX},${y_offset+8}`, 
            fill: 'none', 
            stroke: aColor, 
            "stroke-width": 2.5 
        }));
        drawArrow(svg, centerX, y_offset + V_SPACING, (centerX+leftSumX)/2, y_offset + V_SPACING, aColor, 2.5);
        const txt_a = createEl('text', {x: (centerX+leftSumX)/2, y: y_offset + V_SPACING - 12, class:'coeff-text', fill: aColor});
        txt_a.textContent = -a1;
        svg.appendChild(txt_a);

        // 右侧求和节点
        drawNode(svg, rightSumX, y_offset);

        // 前馈路径 b0
        const color_b0 = bColors.start;
        const b0Color = `rgb(${color_b0.join()})`;
        drawArrow(svg, centerX, y_offset, rightSumX, y_offset, b0Color, 2.5);
        const txt_b0 = createEl('text', {x: (centerX+rightSumX)/2, y: y_offset - 12, class:'coeff-text', fill: b0Color});
        txt_b0.textContent = b0;
        svg.appendChild(txt_b0);

        // 前馈路径 b1
        const color_b1 = bColors.end;
        const b1Color = `rgb(${color_b1.join()})`;
        svg.appendChild(createEl('polyline', { 
            points: `${centerX},${y_offset + V_SPACING} ${rightSumX},${y_offset + V_SPACING} ${rightSumX},${y_offset+8}`, 
            fill: 'none', 
            stroke: b1Color, 
            "stroke-width": 2.5 
        }));
        drawArrow(svg, centerX, y_offset + V_SPACING, (centerX+rightSumX)/2, y_offset + V_SPACING, b1Color, 2.5);
        const txt_b1 = createEl('text', {x: (centerX+rightSumX)/2, y: y_offset + V_SPACING - 12, class:'coeff-text', fill: b1Color});
        txt_b1.textContent = b1;
        svg.appendChild(txt_b1);

        return { inX: leftSumX, outX: rightSumX, y: y_offset };
    };

    // 绘制级联型（通用）
    const drawCascadeForm = (svgId, configs) => {
        const svg = document.getElementById(svgId);
        svg.innerHTML = '';
        
        const WIDTH = 800, HEIGHT = 200;
        svg.setAttribute('viewBox', `0 0 ${WIDTH} ${HEIGHT}`);

        const inputX = 60, outputX = WIDTH - 60;
        const section1X = 150, section2X = 450;
        const sectionY = 80;

        // 输入
        svg.appendChild(createEl('text', { x: inputX - 30, y: sectionY + 5, class: 'io-text' })).textContent = 'x[n]';

        // 第一节
        const sec1 = drawFirstOrderSection(svg, section1X, sectionY, configs.h1.b[0], configs.h1.b[1], configs.h1.a[1]);
        drawArrow(svg, inputX, sectionY, sec1.inX, sectionY);

        // 第二节
        const sec2 = drawFirstOrderSection(svg, section2X, sectionY, configs.h2.b[0], configs.h2.b[1], configs.h2.a[1]);
        drawArrow(svg, sec1.outX, sectionY, sec2.inX, sectionY);

        // 输出
        drawArrow(svg, sec2.outX, sectionY, outputX, sectionY);
        svg.appendChild(createEl('text', { x: outputX + 10, y: sectionY + 5, class: 'io-text' })).textContent = 'y[n]';
    };

    // 绘制并联型
    const drawParallelForm = () => {
        const svg = document.getElementById('flow-graph-parallel');
        svg.innerHTML = '';
        
        const WIDTH = 800, HEIGHT = 400;
        svg.setAttribute('viewBox', `0 0 ${WIDTH} ${HEIGHT}`);

        const inputX = 80, splitX = 150, outputX = 650, joinX = 550;
        const branchX = 250;
        const mainY = 200, y_spacing = 130;
        const y_c0 = mainY - y_spacing;
        const y_h1 = mainY;
        const y_h2 = mainY + y_spacing;

        // 输入
        svg.appendChild(createEl('text', { x: inputX - 30, y: mainY + 5, class: 'io-text' })).textContent = 'x[n]';
        drawArrow(svg, inputX, mainY, splitX, mainY);
        drawNode(svg, splitX, mainY);

        // 分支线
        svg.appendChild(createEl('line', {x1: splitX, y1: y_c0, x2: splitX, y2: y_h2, stroke: '#333', 'stroke-width': 2.5}));

        // 分支1: 常数C0=5
        drawArrow(svg, splitX, y_c0, branchX, y_c0);
        const c0Color = 'purple';
        drawArrow(svg, branchX, y_c0, joinX, y_c0, c0Color, 2.5);
        const txt_c0 = createEl('text', {x: (branchX+joinX)/2, y: y_c0 - 12, class:'coeff-text', fill: c0Color});
        txt_c0.textContent = '5';
        svg.appendChild(txt_c0);

        // 分支2: H1(z) = 10/(1-0.5z^-1)
        const sec1 = drawFirstOrderSection(svg, branchX, y_h1, 10, 0, 0.5);
        drawArrow(svg, splitX, y_h1, sec1.inX, y_h1);
        drawArrow(svg, sec1.outX, y_h1, joinX, y_h1);

        // 分支3: H2(z) = -14/(1-0.2z^-1)
        const sec2 = drawFirstOrderSection(svg, branchX, y_h2, -14, 0, 0.2);
        drawArrow(svg, splitX, y_h2, sec2.inX, y_h2);
        drawArrow(svg, sec2.outX, y_h2, joinX, y_h2);

        // 合并
        svg.appendChild(createEl('line', {x1: joinX, y1: y_c0, x2: joinX, y2: y_h2, stroke: '#333', 'stroke-width': 2.5}));
        drawNode(svg, joinX, mainY);

        // 输出
        drawArrow(svg, joinX, mainY, outputX, mainY);
        svg.appendChild(createEl('text', { x: outputX + 30, y: mainY + 5, class: 'io-text' })).textContent = 'y[n]';
    };

    // 初始化
    displayHz();
    drawDirectFormI();
    drawDirectFormII();

    // 级联型4种配对
    drawCascadeForm('flow-graph-cascade1', {
        h1: {b: [1, 1], a: [1, -0.5]},
        h2: {b: [1, 0.5], a: [1, -0.2]}
    });

    drawCascadeForm('flow-graph-cascade2', {
        h1: {b: [1, 1], a: [1, -0.2]},
        h2: {b: [1, 0.5], a: [1, -0.5]}
    });

    drawCascadeForm('flow-graph-cascade3', {
        h1: {b: [1, 0.5], a: [1, -0.5]},
        h2: {b: [1, 1], a: [1, -0.2]}
    });

    drawCascadeForm('flow-graph-cascade4', {
        h1: {b: [1, 0.5], a: [1, -0.2]},
        h2: {b: [1, 1], a: [1, -0.5]}
    });

    drawParallelForm();
});
</script>

</body>
</html>
