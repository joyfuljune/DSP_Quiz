<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IIR滤波器结构对比展示</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            min-height: 100vh;
            color: #333;
        }
        .main-container {
            max-width: 1600px;
            margin: 0 auto;
        }
        .header {
            text-align: center;
            color: white;
            margin-bottom: 40px;
        }
        .header h1 {
            font-size: 2.8em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        .header .subtitle {
            font-size: 1.3em;
            opacity: 0.95;
            margin-bottom: 10px;
        }
        .header .description {
            font-size: 1.1em;
            opacity: 0.9;
            max-width: 800px;
            margin: 0 auto;
        }
        
        .hz-display {
            background: rgba(255, 255, 255, 0.95);
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.2);
            margin-bottom: 30px;
            text-align: center;
        }
        .hz-display h2 {
            margin-bottom: 20px;
            font-size: 1.5em;
        }
        .hz-formula {
            font-size: 1.3em;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #667eea;
            display: inline-block;
        }
        
        .structures-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(600px, 1fr));
            gap: 25px;
        }
        
        .structure-card {
            background: white;
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.2);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            display: flex;
            flex-direction: column;
        }
        .structure-card:hover {
            transform: translateY(-8px);
            box-shadow: 0 12px 32px rgba(0,0,0,0.25);
        }
        .structure-card h2 {
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 3px solid #667eea;
            font-size: 1.4em;
        }
        
        .decomposition-content {
            font-size: 1.05em;
            line-height: 1.8;
            color: #555;
            margin-bottom: 20px;
        }
        .decomposition-content h3 {
            color: #667eea;
            margin-top: 15px;
            margin-bottom: 10px;
            font-size: 1.2em;
        }
        .decomposition-content p {
            margin-bottom: 10px;
        }

        .flow-graph-svg {
            width: 100%;
            border: 1px solid #e0e0e0;
            background-color: #fdfdfd;
            border-radius: 8px;
            overflow: visible;
            margin-top: auto; /* Pushes SVG to the bottom if content is short */
        }
        
        /* SVG Element Styles */
        .coeff-text { font-weight: bold; font-size: 1.3em; text-anchor: middle; }
        .delay-text { font-size: 1.1em; text-anchor: start; }
        .io-text { font-size: 1.3em; font-weight: bold; }
        .summer-text { font-size: 1.5em; font-weight: bold; }
        .line-main { stroke: #333; stroke-width: 2.5; fill: none; }
        .line-coeff { stroke-width: 2.5; fill: none; }
        .intermediate-text { font-style: italic; font-size: 1.1em; text-anchor: middle; }
        
        @media (max-width: 1280px) {
            .structures-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>

<div class="main-container">
    <header class="header">
        <h1>IIR滤波器结构对比</h1>
        <div class="subtitle">直接I型 · 直接II型 · 级联型 · 并联型</div>
        <p class="description">
            同一个传递函数可以通过不同的结构来实现。本页可视化展示了一个二阶IIR滤波器的四种经典实现结构，并解释了级联型和并联型的数学分解过程。
        </p>
    </header>

    <!-- 传递函数显示 -->
    <section class="hz-display">
        <h2>系统传递函数 H(z)</h2>
        <div id="hz-formula" class="hz-formula"></div>
    </section>

    <!-- 统一网格布局 -->
    <main class="structures-grid">

        <!-- 直接I型 -->
        <article class="structure-card">
            <h2>直接I型 (Direct Form I)</h2>
            <svg id="flow-graph-I" class="flow-graph-svg"></svg>
        </article>

        <!-- 直接II型 -->
        <article class="structure-card">
            <h2>直接II型 (Direct Form II)</h2>
            <svg id="flow-graph-II" class="flow-graph-svg"></svg>
        </article>

        <!-- 级联型 (整合版) -->
        <article class="structure-card">
            <h2>级联型 (Cascade Form)</h2>
            <div id="cascade-decomposition" class="decomposition-content">
                <h3>数学分解</h3>
                <p>将高阶传递函数分解为若干个一阶或二阶节的乘积：$$ H(z) = H_1(z) H_2(z) \dots H_k(z) $$</p>
                <p><strong>分子:</strong> $$ B(z) = 1 + 1.5z^{-1} + 0.5z^{-2} = (1 + 1z^{-1})(1 + 0.5z^{-1}) $$</p>
                <p><strong>分母:</strong> $$ A(z) = 1 - 0.7z^{-1} + 0.1z^{-2} = (1 - 0.5z^{-1})(1 - 0.2z^{-1}) $$</p>
                <p>将零点和极点配对，得到两个一阶节的串联：</p>
                $$ H(z) = \underbrace{\left( \frac{1 + z^{-1}}{1 - 0.5z^{-1}} \right)}_{H_1(z)} \cdot \underbrace{\left( \frac{1 + 0.5z^{-1}}{1 - 0.2z^{-1}} \right)}_{H_2(z)} $$
            </div>
            <svg id="flow-graph-cascade" class="flow-graph-svg"></svg>
        </article>
        
        <!-- 并联型 (整合版) -->
        <article class="structure-card">
            <h2>并联型 (Parallel Form)</h2>
            <div id="parallel-decomposition" class="decomposition-content">
                <h3>数学分解</h3>
                <p>通过部分分式展开，将传递函数分解为若干项的和。由于分子分母阶次相同，先提取常数项 C₀:</p>
                <p><strong>常数项:</strong> $$ C_0 = \frac{b_2}{a_2} = \frac{0.5}{0.1} = 5 $$</p>
                <p><strong>余项部分分式展开:</strong> $$ H(z) - C_0 = \frac{-4 + 5z^{-1}}{1 - 0.7z^{-1} + 0.1z^{-2}} = \frac{10}{1 - 0.5z^{-1}} + \frac{-14}{1 - 0.2z^{-1}} $$</p>
                <p><strong>最终形式:</strong></p>
                $$ H(z) = 5 + \frac{10}{1 - 0.5z^{-1}} + \frac{-14}{1 - 0.2z^{-1}} $$
            </div>
            <svg id="flow-graph-parallel" class="flow-graph-svg"></svg>
        </article>

    </main>
</div>

<script>
// JavaScript部分与原版完全相同，无需修改
document.addEventListener('DOMContentLoaded', () => {
    // 1. 使用简单的二阶数值示例
    const COEFFS = {
        b: [1, 1.5, 0.5],    // b0, b1, b2
        a: [1, -0.7, 0.1]    // 1, a1, a2
    };
    const N = 2; // 分子阶次
    const M = 2; // 分母阶次

    const interpolateColor = (color1, color2, factor) => {
        const result = color1.slice();
        for (let i = 0; i < 3; i++) {
            result[i] = Math.round(result[i] + factor * (color2[i] - result[i]));
        }
        return `rgb(${result[0]}, ${result[1]}, ${result[2]})`;
    };
    
    const bColors = { start: [0, 123, 255], end: [108, 0, 255] }; 
    const aColors = { start: [255, 193, 7], end: [220, 53, 69] };

    // 显示传递函数
    const displayHz = () => {
        const numTerms = COEFFS.b.map((c, i) => `${c >= 0 ? (i>0 ? '+' : '') : ''}${c}${i > 0 ? `z^{-${i}}` : ''}`).join(' ');
        const denTerms = COEFFS.a.slice(1).map((c, i) => `${c >= 0 ? '+' : ''}${c}z^{-${i+1}}`).join(' ');
        
        document.getElementById('hz-formula').innerHTML = `$$ H(z) = \\frac{${numTerms}}{1 ${denTerms}} $$`;
        
        if (window.renderMathInElement) {
            renderMathInElement(document.body);
        }
    };

    // 绘制直接I型
    const drawDirectFormI = () => {
        const svg = document.getElementById('flow-graph-I');
        svg.innerHTML = '';
        
        const width = 700;
        const height = 220;
        svg.setAttribute('viewBox', `0 0 ${width} ${height}`);

        const H_SPACING = 160, V_SPACING = 60, NODE_RADIUS = 10, IN_OUT_OFFSET = 80;
        const x_delay_x = IN_OUT_OFFSET + 80;
        const y_delay_x = width - IN_OUT_OFFSET - 80;
        const summer1_x = x_delay_x + H_SPACING / 2;
        const summer2_x = y_delay_x - H_SPACING / 2;
        const startY = 50;
        
        const S = (el, attrs) => {
            const e = document.createElementNS('http://www.w3.org/2000/svg', el);
            for (const k in attrs) e.setAttribute(k, attrs[k]);
            svg.appendChild(e);
            return e;
        };
        
        const P = (x1, y1, x2, y2, color) => {
            const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;
            const midX = (x1 + x2) / 2, midY = (y1 + y2) / 2, size = 10;
            S('path', { 
                d: `M 0 0 L ${-size} ${-size/2} L ${-size} ${size/2} z`, 
                fill: color, 
                transform: `translate(${midX}, ${midY}) rotate(${angle})` 
            });
        };

        S('line', { x1: IN_OUT_OFFSET, y1: startY, x2: x_delay_x, y2: startY, class: 'line-main' });
        P(IN_OUT_OFFSET, startY, x_delay_x, startY, '#333');
        S('text', { x: IN_OUT_OFFSET - 25, y: startY + 5, class: 'io-text' }).textContent = 'x[n]';
        
        for (let i = 0; i < N; i++) {
            const y1 = startY + i * V_SPACING, y2 = startY + (i + 1) * V_SPACING;
            S('line', { x1: x_delay_x, y1: y1, x2: x_delay_x, y2: y2, class: 'line-main' });
            P(x_delay_x, y1, x_delay_x, y2, '#333');
            S('circle', { cx: x_delay_x, cy: y1, r: NODE_RADIUS, fill: 'white', stroke: '#333', 'stroke-width': 2 });
            S('text', { x: x_delay_x + 15, y: y1 + V_SPACING / 2 + 5, class: 'delay-text' }).textContent = 'z⁻¹';
        }
        S('circle', { cx: x_delay_x, cy: startY + N * V_SPACING, r: NODE_RADIUS, fill: 'white', stroke: '#333', 'stroke-width': 2 });

        S('circle', { cx: summer1_x, cy: startY, r: NODE_RADIUS, fill: 'white', stroke: '#333', 'stroke-width': 2 });
        S('text', { x: summer1_x - 1, y: startY + 7, class: 'summer-text' }).textContent = '+';

        for (let i = 0; i <= N; i++) {
            const y = startY + i * V_SPACING;
            const color = interpolateColor(bColors.start, bColors.end, N > 0 ? i / N : 0);
            S('line', { x1: x_delay_x, y1: y, x2: summer1_x, y2: y, class: 'line-coeff', stroke: color });
            P(x_delay_x, y, summer1_x, y, color);
            S('text', { x: x_delay_x + (summer1_x - x_delay_x) / 2, y: y - 10, class: 'coeff-text', fill: color }).textContent = COEFFS.b[i];
            if (i > 0) {
                S('line', { x1: summer1_x, y1: y, x2: summer1_x, y2: startY, class: 'line-coeff', stroke: color });
                P(summer1_x, y, summer1_x, startY, color);
            }
        }

        S('line', { x1: summer1_x, y1: startY, x2: summer2_x, y2: startY, class: 'line-main' });
        P(summer1_x, startY, summer2_x, startY, '#333');
        S('text', { x: (summer1_x + summer2_x) / 2, y: startY - 15, class: 'io-text' }).textContent = 'w[n]';
        
        S('circle', { cx: summer2_x, cy: startY, r: NODE_RADIUS, fill: 'white', stroke: '#333', 'stroke-width': 2 });
        S('text', { x: summer2_x - 1, y: startY + 7, class: 'summer-text' }).textContent = '+';
        S('line', { x1: summer2_x, y1: startY, x2: y_delay_x, y2: startY, class: 'line-main' });
        P(summer2_x, startY, y_delay_x, startY, '#333');

        for (let i = 0; i < M; i++) {
            const y1 = startY + i * V_SPACING, y2 = startY + (i + 1) * V_SPACING;
            S('line', { x1: y_delay_x, y1: y1, x2: y_delay_x, y2: y2, class: 'line-main' });
            P(y_delay_x, y1, y_delay_x, y2, '#333');
            S('circle', { cx: y_delay_x, cy: y1, r: NODE_RADIUS, fill: 'white', stroke: '#333', 'stroke-width': 2 });
            S('text', { x: y_delay_x + 15, y: y1 + V_SPACING / 2 + 5, class: 'delay-text' }).textContent = 'z⁻¹';
        }
        S('circle', { cx: y_delay_x, cy: startY + M * V_SPACING, r: NODE_RADIUS, fill: 'white', stroke: '#333', 'stroke-width': 2 });

        for (let i = 1; i <= M; i++) {
            const y = startY + i * V_SPACING;
            const color = interpolateColor(aColors.start, aColors.end, M > 1 ? (i-1)/(M-1) : 0);
            S('line', { x1: y_delay_x, y1: y, x2: summer2_x, y2: y, class: 'line-coeff', stroke: color });
            P(y_delay_x, y, summer2_x, y, color);
            S('text', { x: y_delay_x - (y_delay_x - summer2_x) / 2, y: y - 10, class: 'coeff-text', fill: color }).textContent = -COEFFS.a[i];
            S('line', { x1: summer2_x, y1: y, x2: summer2_x, y2: startY, class: 'line-coeff', stroke: color });
            P(summer2_x, y, summer2_x, startY, color);
        }
        
        S('line', { x1: y_delay_x, y1: startY, x2: width - IN_OUT_OFFSET, y2: startY, class: 'line-main' });
        P(y_delay_x, startY, width - IN_OUT_OFFSET, startY, '#333');
        S('text', { x: width - IN_OUT_OFFSET + 25, y: startY + 5, class: 'io-text' }).textContent = 'y[n]';
    };

    // 绘制直接II型
    const drawDirectFormII = () => {
        const svg = document.getElementById('flow-graph-II');
        svg.innerHTML = '';
        
        const width = 700;
        const height = 220;
        svg.setAttribute('viewBox', `0 0 ${width} ${height}`);

        const V_SPACING = 60, NODE_RADIUS = 10, IN_OUT_OFFSET = 80;
        const centerX = width / 2;
        const summer_offset = 130;
        const startY = 50;

        const S = (el, attrs) => {
            const e = document.createElementNS('http://www.w3.org/2000/svg', el);
            for (const k in attrs) e.setAttribute(k, attrs[k]);
            svg.appendChild(e);
            return e;
        };
        
        const P = (x1, y1, x2, y2, color) => {
            const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;
            const midX = (x1 + x2) / 2, midY = (y1 + y2) / 2, size = 10;
            S('path', { d: `M 0 0 L ${-size} ${-size/2} L ${-size} ${size/2} z`, fill: color, transform: `translate(${midX}, ${midY}) rotate(${angle})` });
        };

        const L = Math.max(N, M);
        
        for (let i = 0; i < L; i++) {
            const y1 = startY + i * V_SPACING, y2 = startY + (i + 1) * V_SPACING;
            S('line', { x1: centerX, y1: y1, x2: centerX, y2: y2, class: 'line-main' });
            P(centerX, y1, centerX, y2, '#333');
            S('circle', { cx: centerX, cy: y1, r: NODE_RADIUS, fill: 'white', stroke: '#333', 'stroke-width': 2 });
            S('text', { x: centerX + 15, y: y1 + V_SPACING / 2 + 5, class: 'delay-text' }).textContent = 'z⁻¹';
        }
        if (L > 0) S('circle', { cx: centerX, cy: startY + L * V_SPACING, r: NODE_RADIUS, fill: 'white', stroke: '#333', 'stroke-width': 2 });
        S('text', { x: centerX, y: startY - 15, class: 'io-text', 'text-anchor': 'middle' }).textContent = 'w[n]';

        const summer_feedback_x = centerX - summer_offset;
        S('line', { x1: IN_OUT_OFFSET, y1: startY, x2: summer_feedback_x, y2: startY, class: 'line-main' });
        P(IN_OUT_OFFSET, startY, summer_feedback_x, startY, '#333');
        S('text', { x: IN_OUT_OFFSET - 25, y: startY + 5, class: 'io-text' }).textContent = 'x[n]';
        S('circle', { cx: summer_feedback_x, cy: startY, r: NODE_RADIUS, fill: 'white', stroke: '#333', 'stroke-width': 2 });
        S('text', { x: summer_feedback_x - 1, y: startY + 7, class: 'summer-text' }).textContent = '+';
        S('line', { x1: summer_feedback_x, y1: startY, x2: centerX, y2: startY, class: 'line-main' });
        P(summer_feedback_x, startY, centerX, startY, '#333');

        for (let i = 1; i <= M; i++) {
            const y = startY + i * V_SPACING;
            const color = interpolateColor(aColors.start, aColors.end, M > 1 ? (i - 1) / (M - 1) : 0);
            const coeff_x = centerX - summer_offset/2;
            S('line', { x1: centerX, y1: y, x2: coeff_x, y2: y, class: 'line-coeff', stroke: color });
            P(centerX, y, coeff_x, y, color);
            S('line', { x1: coeff_x, y1: y, x2: summer_feedback_x, y2: y, class: 'line-coeff', stroke: color });
            P(coeff_x, y, summer_feedback_x, y, color);
            S('line', { x1: summer_feedback_x, y1: y, x2: summer_feedback_x, y2: startY, class: 'line-coeff', stroke: color });
            P(summer_feedback_x, y, summer_feedback_x, startY, color);
            S('text', { x: coeff_x, y: y - 10, class: 'coeff-text', fill: color }).textContent = -COEFFS.a[i];
        }

        const summer_feedforward_x = centerX + summer_offset;
        S('line', { x1: summer_feedforward_x, y1: startY, x2: width - IN_OUT_OFFSET, y2: startY, class: 'line-main' });
        P(summer_feedforward_x, startY, width - IN_OUT_OFFSET, startY, '#333');
        S('text', { x: width - IN_OUT_OFFSET + 25, y: startY + 5, class: 'io-text' }).textContent = 'y[n]';
        S('circle', { cx: summer_feedforward_x, cy: startY, r: NODE_RADIUS, fill: 'white', stroke: '#333', 'stroke-width': 2 });
        S('text', { x: summer_feedforward_x - 1, y: startY + 7, class: 'summer-text' }).textContent = '+';

        for (let i = 0; i <= N; i++) {
            const y = startY + i * V_SPACING;
            const color = interpolateColor(bColors.start, bColors.end, N > 0 ? i / N : 0);
            const coeff_x = centerX + summer_offset/2;

            if (i === 0) {
                S('line', { x1: centerX, y1: y, x2: summer_feedforward_x, y2: y, class: 'line-coeff', stroke: color });
                P(centerX, y, summer_feedforward_x, y, color);
                S('text', { x: coeff_x, y: y - 10, class: 'coeff-text', fill: color }).textContent = COEFFS.b[i];
            } else {
                S('line', { x1: centerX, y1: y, x2: coeff_x, y2: y, class: 'line-coeff', stroke: color });
                P(centerX, y, coeff_x, y, color);
                S('line', { x1: coeff_x, y1: y, x2: summer_feedforward_x, y2: y, class: 'line-coeff', stroke: color });
                P(coeff_x, y, summer_feedforward_x, y, color);
                S('line', { x1: summer_feedforward_x, y1: y, x2: summer_feedforward_x, y2: startY, class: 'line-coeff', stroke: color });
                P(summer_feedforward_x, y, summer_feedforward_x, startY, color);
                S('text', { x: coeff_x, y: y - 10, class: 'coeff-text', fill: color }).textContent = COEFFS.b[i];
            }
        }
    };

    // 绘制级联型流图
    const drawCascadeForm = () => {
        const svg = document.getElementById('flow-graph-cascade');
        svg.innerHTML = '';
        
        const width = 800;
        const height = 250;
        svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
        
        const S = (el, attrs) => {
            const e = document.createElementNS('http://www.w3.org/2000/svg', el);
            for (const k in attrs) e.setAttribute(k, attrs[k]);
            svg.appendChild(e); return e;
        };
        const P = (x1, y1, x2, y2, color) => {
            const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;
            const midX = (x1 + x2) / 2, midY = (y1 + y2) / 2, size = 8;
            S('path', { d: `M 0 0 L ${-size} ${-size/2} L ${-size} ${size/2} z`, fill: color, transform: `translate(${midX}, ${midY}) rotate(${angle})` });
        };

        const drawFirstOrderSection = (x_offset, y_offset, coeffs) => {
            const summer_offset = 70, v_spacing = 60;
            const centerX = x_offset + summer_offset;
            const summer_L = x_offset;
            const summer_R = x_offset + 2 * summer_offset;
            
            S('rect', {x: x_offset-20, y: y_offset-40, width: 2*summer_offset+40, height: v_spacing+80, fill: 'rgba(102,126,234,0.05)', stroke: 'rgba(102,126,234,0.5)', 'stroke-dasharray':'5,5', rx:8});
            S('text', {x: centerX, y: y_offset-20, 'text-anchor': 'middle', 'font-weight': 'bold'}).textContent = coeffs.name;

            S('circle', { cx: summer_L, cy: y_offset, r: 8, fill: 'white', stroke: '#333', 'stroke-width': 2 });
            S('text', { x: summer_L - 1, y: y_offset + 6, class: 'summer-text' }).textContent = '+';
            S('line', { x1: summer_L, y1: y_offset, x2: centerX, y2: y_offset, class: 'line-main' }); P(summer_L, y_offset, centerX, y_offset, '#333');
            
            S('line', { x1: centerX, y1: y_offset, x2: centerX, y2: y_offset + v_spacing, class: 'line-main' }); P(centerX, y_offset, centerX, y_offset + v_spacing, '#333');
            S('circle', { cx: centerX, cy: y_offset, r: 8, fill: 'white', stroke: '#333', 'stroke-width': 2 });
            S('text', { x: centerX + 10, y: y_offset + v_spacing/2 + 5, class: 'delay-text' }).textContent = 'z⁻¹';
            
            const color_a = `rgb(${aColors.start.join()})`;
            S('line', { x1: centerX, y1: y_offset + v_spacing, x2: summer_L, y2: y_offset + v_spacing, class: 'line-coeff', stroke: color_a }); P(centerX, y_offset + v_spacing, summer_L, y_offset + v_spacing, color_a);
            S('line', { x1: summer_L, y1: y_offset + v_spacing, x2: summer_L, y2: y_offset, class: 'line-coeff', stroke: color_a }); P(summer_L, y_offset + v_spacing, summer_L, y_offset, color_a);
            S('text', { x: centerX - summer_offset/2, y: y_offset + v_spacing - 8, class: 'coeff-text', fill: color_a }).textContent = -coeffs.a[1];

            S('circle', { cx: summer_R, cy: y_offset, r: 8, fill: 'white', stroke: '#333', 'stroke-width': 2 });
            S('text', { x: summer_R - 1, y: y_offset + 6, class: 'summer-text' }).textContent = '+';
            
            const color_b0 = `rgb(${bColors.start.join()})`;
            S('line', { x1: centerX, y1: y_offset, x2: summer_R, y2: y_offset, class: 'line-coeff', stroke: color_b0 }); P(centerX, y_offset, summer_R, y_offset, color_b0);
            S('text', { x: centerX + summer_offset/2, y: y_offset - 8, class: 'coeff-text', fill: color_b0 }).textContent = coeffs.b[0];

            const color_b1 = `rgb(${bColors.end.join()})`;
            S('line', { x1: centerX, y1: y_offset + v_spacing, x2: summer_R, y2: y_offset + v_spacing, class: 'line-coeff', stroke: color_b1 }); P(centerX, y_offset + v_spacing, summer_R, y_offset + v_spacing, color_b1);
            S('line', { x1: summer_R, y1: y_offset + v_spacing, x2: summer_R, y2: y_offset, class: 'line-coeff', stroke: color_b1 }); P(summer_R, y_offset + v_spacing, summer_R, y_offset, color_b1);
            S('text', { x: centerX + summer_offset/2, y: y_offset + v_spacing - 8, class: 'coeff-text', fill: color_b1 }).textContent = coeffs.b[1];
        };

        const section1_x = 120, section_y = 100;
        const section2_x = 450;
        
        drawFirstOrderSection(section1_x, section_y, {name:'H₁(z)', b:[1,1], a:[1,-0.5]});
        drawFirstOrderSection(section2_x, section_y, {name:'H₂(z)', b:[1,0.5], a:[1,-0.2]});
        
        S('text', { x: 30, y: section_y + 5, class: 'io-text' }).textContent = 'x[n]';
        S('line', { x1: 50, y1: section_y, x2: section1_x, y2: section_y, class: 'line-main' }); P(50, section_y, section1_x, section_y, '#333');
        
        const h1_out_x = section1_x + 140;
        const h2_in_x = section2_x;
        S('line', { x1: h1_out_x, y1: section_y, x2: h2_in_x, y2: section_y, class: 'line-main' }); P(h1_out_x, section_y, h2_in_x, section_y, '#333');
        S('text', {x: (h1_out_x+h2_in_x)/2, y: section_y-10, class:'intermediate-text'}).textContent = 'w₁[n]';

        const h2_out_x = section2_x + 140;
        S('line', { x1: h2_out_x, y1: section_y, x2: h2_out_x + 50, y2: section_y, class: 'line-main' }); P(h2_out_x, section_y, h2_out_x+50, section_y, '#333');
        S('text', { x: h2_out_x + 70, y: section_y + 5, class: 'io-text' }).textContent = 'y[n]';
    };

    // 绘制并联型流图
    const drawParallelForm = () => {
        const svg = document.getElementById('flow-graph-parallel');
        svg.innerHTML = '';
        
        const width = 800;
        const height = 400;
        svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
        
        const S = (el, attrs) => {
            const e = document.createElementNS('http://www.w3.org/2000/svg', el);
            for (const k in attrs) e.setAttribute(k, attrs[k]);
            svg.appendChild(e); return e;
        };
        const P = (x1, y1, x2, y2, color) => {
            const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;
            const midX = (x1 + x2) / 2, midY = (y1 + y2) / 2, size = 8;
            S('path', { d: `M 0 0 L ${-size} ${-size/2} L ${-size} ${size/2} z`, fill: color, transform: `translate(${midX}, ${midY}) rotate(${angle})` });
        };

        const drawFirstOrderParallelBranch = (x_offset, y_offset, coeffs) => {
            const summer_offset = 70, v_spacing = 60;
            const centerX = x_offset + summer_offset;
            const summer_L = x_offset;
            const coeff_R_x = x_offset + 2 * summer_offset;

            S('circle', { cx: summer_L, cy: y_offset, r: 8, fill: 'white', stroke: '#333', 'stroke-width': 2 });
            S('text', { x: summer_L - 1, y: y_offset + 6, class: 'summer-text' }).textContent = '+';
            S('line', { x1: summer_L, y1: y_offset, x2: centerX, y2: y_offset, class: 'line-main' }); P(summer_L, y_offset, centerX, y_offset, '#333');
            
            S('line', { x1: centerX, y1: y_offset, x2: centerX, y2: y_offset + v_spacing, class: 'line-main' }); P(centerX, y_offset, centerX, y_offset + v_spacing, '#333');
            S('circle', { cx: centerX, cy: y_offset, r: 8, fill: 'white', stroke: '#333', 'stroke-width': 2 });
            S('text', { x: centerX + 10, y: y_offset + v_spacing/2 + 5, class: 'delay-text' }).textContent = 'z⁻¹';
            
            const color_a = `rgb(${aColors.start.join()})`;
            S('line', { x1: centerX, y1: y_offset + v_spacing, x2: summer_L, y2: y_offset + v_spacing, class: 'line-coeff', stroke: color_a }); P(centerX, y_offset + v_spacing, summer_L, y_offset + v_spacing, color_a);
            S('line', { x1: summer_L, y1: y_offset + v_spacing, x2: summer_L, y2: y_offset, class: 'line-coeff', stroke: color_a }); P(summer_L, y_offset + v_spacing, summer_L, y_offset, color_a);
            S('text', { x: centerX - summer_offset/2, y: y_offset + v_spacing - 8, class: 'coeff-text', fill: color_a }).textContent = -coeffs.a[1];

            const color_b0 = `rgb(${bColors.start.join()})`;
            S('line', { x1: centerX, y1: y_offset, x2: coeff_R_x, y2: y_offset, class: 'line-coeff', stroke: color_b0 }); P(centerX, y_offset, coeff_R_x, y_offset, color_b0);
            S('text', { x: centerX + summer_offset/2, y: y_offset - 8, class: 'coeff-text', fill: color_b0 }).textContent = coeffs.b[0];

            return { in: {x: summer_L, y: y_offset}, out: {x: coeff_R_x, y: y_offset} };
        };
        
        const inputX = 80, splitX = 150, branchX = 250, joinX = 550, outputX = 650;
        const mainY = 200, y_spacing = 130;
        const y_c0 = mainY - y_spacing;
        const y_h1 = mainY;
        const y_h2 = mainY + y_spacing;

        S('text', { x: inputX - 30, y: mainY + 5, class: 'io-text' }).textContent = 'x[n]';
        S('line', { x1: inputX, y1: mainY, x2: splitX, y2: mainY, class: 'line-main' }); P(inputX, mainY, splitX, mainY, '#333');
        S('circle', { cx: splitX, cy: mainY, r: 6, fill: '#333'});
        S('line', {x1: splitX, y1: y_c0, x2:splitX, y2: y_h2, class: 'line-main'});

        // Branch 1: C0
        const color_c0 = 'purple';
        S('line', {x1: splitX, y1: y_c0, x2: branchX, y2: y_c0, class: 'line-main'}); P(splitX, y_c0, branchX, y_c0, '#333');
        S('line', {x1: branchX, y1: y_c0, x2: joinX, y2: y_c0, class: 'line-coeff', stroke: color_c0}); P(branchX, y_c0, joinX, y_c0, color_c0);
        S('text', {x: (branchX+joinX)/2, y: y_c0-8, class:'coeff-text', fill:color_c0}).textContent = '5';
        
        // Branch 2: H1(z)
        const branch1_nodes = drawFirstOrderParallelBranch(branchX, y_h1, {b:[10], a:[1,-0.5]});
        S('line', {x1: splitX, y1: y_h1, x2: branch1_nodes.in.x, y2: y_h1, class: 'line-main'}); P(splitX, y_h1, branch1_nodes.in.x, y_h1, '#333');
        S('line', {x1: branch1_nodes.out.x, y1: y_h1, x2: joinX, y2: y_h1, class: 'line-main'}); P(branch1_nodes.out.x, y_h1, joinX, y_h1, '#333');

        // Branch 3: H2(z)
        const branch2_nodes = drawFirstOrderParallelBranch(branchX, y_h2, {b:[-14], a:[1,-0.2]});
        S('line', {x1: splitX, y1: y_h2, x2: branch2_nodes.in.x, y2: y_h2, class: 'line-main'}); P(splitX, y_h2, branch2_nodes.in.x, y_h2, '#333');
        S('line', {x1: branch2_nodes.out.x, y1: y_h2, x2: joinX, y2: y_h2, class: 'line-main'}); P(branch2_nodes.out.x, y_h2, joinX, y_h2, '#333');
        
        // 合并
        S('line', {x1:joinX, y1: y_c0, x2: joinX, y2: mainY, class: 'line-main'}); P(joinX, y_c0, joinX, mainY, '#333');
        S('line', {x1:joinX, y1: y_h2, x2: joinX, y2: mainY, class: 'line-main'}); P(joinX, y_h2, joinX, mainY, '#333');
        S('circle', { cx: joinX, cy: mainY, r: 10, fill: 'white', stroke: '#333', 'stroke-width': 2 });
        S('text', { x: joinX - 1, y: mainY + 7, class: 'summer-text' }).textContent = '+';
        
        // 输出
        S('line', { x1: joinX, y1: mainY, x2: outputX, y2: mainY, class: 'line-main' }); P(joinX, mainY, outputX, mainY, '#333');
        S('text', { x: outputX + 30, y: mainY + 5, class: 'io-text' }).textContent = 'y[n]';
    };

    // 初始化显示所有内容
    displayHz();
    drawDirectFormI();
    drawDirectFormII();
    drawCascadeForm();
    drawParallelForm();
});
</script>

</body>
</html>