<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é›¶æç‚¹ä¸é¢‘ç‡å“åº”äº¤äº’å¼æ¼”ç¤º</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            }
        };
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            padding: 30px;
        }

        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 2em;
        }

        .subtitle {
            text-align: center;
            color: #7f8c8d;
            margin-bottom: 30px;
            font-size: 1.1em;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .panel {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .panel h2 {
            color: #34495e;
            margin-bottom: 15px;
            font-size: 1.3em;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }

        canvas {
            display: block;
            margin: 0 auto;
            border: 2px solid #ddd;
            border-radius: 8px;
            background: white;
            cursor: crosshair;
        }

        .controls {
            background: #ecf0f1;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .control-group {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        button {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .btn-zero {
            background: #3498db;
            color: white;
        }

        .btn-pole {
            background: #e74c3c;
            color: white;
        }

        .btn-clear {
            background: #95a5a6;
            color: white;
        }

        .btn-preset {
            background: #2ecc71;
            color: white;
        }

        .preset-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }

        .info-box {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            border-left: 4px solid #3498db;
        }

        .info-box h3 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .math-formula {
            font-family: 'Courier New', monospace;
            background: #f5f5f5;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            overflow-x: auto;
            font-size: 0.95em;
        }

        .legend {
            display: flex;
            gap: 20px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
        }

        .legend-symbol {
            width: 20px;
            height: 20px;
            border: 2px solid #333;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 15px;
        }

        .stat-item {
            background: white;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
        }

        .stat-label {
            font-size: 12px;
            color: #7f8c8d;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 18px;
            font-weight: bold;
            color: #2c3e50;
        }

        .instruction {
            background: #fff3cd;
            border: 2px solid #ffc107;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .instruction h3 {
            color: #856404;
            margin-bottom: 10px;
        }

        .instruction ul {
            margin-left: 20px;
            color: #856404;
        }

        .instruction li {
            margin: 5px 0;
        }

        @media (max-width: 968px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>é›¶æç‚¹ä¸é¢‘ç‡å“åº”äº¤äº’å¼æ¼”ç¤º</h1>
        <p class="subtitle">å—äº¬å·¥ä¸šå¤§å­¦æµ¦æ±Ÿå­¦é™¢ | æ‹–åŠ¨é›¶æç‚¹è§‚å¯Ÿå¹…åº¦é¢‘ç‡å“åº”çš„å®æ—¶å˜åŒ–</p>

        <div class="instruction">
            <h3>ğŸ“Œ ä½¿ç”¨è¯´æ˜</h3>
            <ul>
                <li><strong>æ·»åŠ é›¶ç‚¹/æç‚¹ï¼š</strong> ç‚¹å‡»å¯¹åº”æŒ‰é’®åï¼Œåœ¨zå¹³é¢å›¾ä¸Šç‚¹å‡»æ·»åŠ </li>
                <li><strong>ç§»åŠ¨é›¶æç‚¹ï¼š</strong> ç›´æ¥æ‹–åŠ¨åœ†åœˆ(é›¶ç‚¹)æˆ–å‰å·(æç‚¹)åˆ°æ–°ä½ç½®</li>
                <li><strong>åˆ é™¤é›¶æç‚¹ï¼š</strong> åŒå‡»è¦åˆ é™¤çš„é›¶ç‚¹æˆ–æç‚¹</li>
                <li><strong>å¿«é€Ÿä½“éªŒï¼š</strong> ç‚¹å‡»ä¸‹æ–¹é¢„è®¾æŒ‰é’®åŠ è½½å…¸å‹é…ç½®</li>
            </ul>
        </div>

        <div class="controls">
            <h3 style="margin-bottom: 15px; color: #2c3e50;">æ§åˆ¶é¢æ¿</h3>
            <div class="control-group">
                <button class="btn-zero" onclick="setMode('zero')">â• æ·»åŠ é›¶ç‚¹</button>
                <button class="btn-pole" onclick="setMode('pole')">â• æ·»åŠ æç‚¹</button>
                <button class="btn-clear" onclick="clearAll()">ğŸ—‘ï¸ æ¸…é™¤å…¨éƒ¨</button>
            </div>

            <h4 style="margin-top: 20px; margin-bottom: 10px; color: #2c3e50;">å…¸å‹é…ç½®ç¤ºä¾‹ï¼š</h4>
            <div class="preset-buttons">
                <button class="btn-preset" onclick="loadPreset('lowpass')">ä½é€šæ»¤æ³¢å™¨</button>
                <button class="btn-preset" onclick="loadPreset('highpass')">é«˜é€šæ»¤æ³¢å™¨</button>
                <button class="btn-preset" onclick="loadPreset('bandpass')">å¸¦é€šæ»¤æ³¢å™¨</button>
                <button class="btn-preset" onclick="loadPreset('notch')">é™·æ³¢æ»¤æ³¢å™¨</button>
                <button class="btn-preset" onclick="loadPreset('resonator')">è°æŒ¯å™¨</button>
                <button class="btn-preset" onclick="loadPreset('multiple')">å¤šé›¶æç‚¹</button>
                <button class="btn-preset" onclick="loadPreset('repeated')">é‡é›¶æç‚¹</button>
            </div>
        </div>

        <div class="main-content">
            <div class="panel">
                <h2>zå¹³é¢ - é›¶æç‚¹å›¾</h2>
                <canvas id="zPlaneCanvas" width="500" height="500"></canvas>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-symbol" style="border-radius: 50%; background: white;">â—‹</div>
                        <span>é›¶ç‚¹ (Zeros)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-symbol">âœ•</div>
                        <span>æç‚¹ (Poles)</span>
                    </div>
                    <div class="legend-item">
                        <div style="width: 20px; height: 2px; background: #3498db; border: 1px solid #3498db;"></div>
                        <span>å•ä½åœ†</span>
                    </div>
                </div>
                <div class="stats">
                    <div class="stat-item">
                        <div class="stat-label">é›¶ç‚¹æ•°é‡</div>
                        <div class="stat-value" id="zeroCount">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">æç‚¹æ•°é‡</div>
                        <div class="stat-value" id="poleCount">0</div>
                    </div>
                </div>
            </div>

            <div class="panel">
                <h2>å¹…åº¦é¢‘ç‡å“åº” $|H(e^{j\omega})|$</h2>
                <canvas id="freqResponseCanvas" width="500" height="500"></canvas>
                <div class="info-box">
                    <h3>ç³»ç»Ÿç‰¹æ€§</h3>
                    <div id="systemInfo" class="math-formula">
                        ç­‰å¾…æ·»åŠ é›¶æç‚¹...
                    </div>
                </div>
            </div>
        </div>

        <div class="info-box">
            <h3>ğŸ“š ç†è®ºçŸ¥è¯†</h3>
            <p><strong>ç³»ç»Ÿå‡½æ•°ï¼š</strong> $H(z) = K \cdot \frac{\prod_{i=1}^{M}(z - z_i)}{\prod_{i=1}^{N}(z - p_i)}$</p>
            <p style="margin-top: 10px;"><strong>é¢‘ç‡å“åº”ï¼š</strong> $H(e^{j\omega}) = H(z)|_{z=e^{j\omega}}$</p>
            <p style="margin-top: 10px;"><strong>å¹…åº¦å“åº”ï¼š</strong> åœ¨å•ä½åœ†ä¸Šï¼ŒæŸé¢‘ç‡ç‚¹çš„å¹…åº¦ç”±è¯¥ç‚¹åˆ°æ‰€æœ‰é›¶ç‚¹çš„è·ç¦»ä¹˜ç§¯é™¤ä»¥åˆ°æ‰€æœ‰æç‚¹çš„è·ç¦»ä¹˜ç§¯å†³å®š</p>
            <p style="margin-top: 10px;">$$|H(e^{j\omega})| = K \cdot \frac{\prod_{i=1}^{M}|e^{j\omega} - z_i|}{\prod_{i=1}^{N}|e^{j\omega} - p_i|}$$</p>
            <ul style="margin-top: 10px; margin-left: 20px;">
                <li><strong>é›¶ç‚¹</strong>ä½¿å…¶é™„è¿‘é¢‘ç‡çš„å“åº”<strong>è¡°å‡</strong>ï¼ˆåˆ†å­ä¸º0ï¼‰</li>
                <li><strong>æç‚¹</strong>ä½¿å…¶é™„è¿‘é¢‘ç‡çš„å“åº”<strong>å¢å¼º</strong>ï¼ˆåˆ†æ¯æ¥è¿‘0ï¼‰</li>
                <li>æç‚¹å¿…é¡»åœ¨å•ä½åœ†å†…ä»¥ä¿è¯ç³»ç»Ÿ<strong>ç¨³å®š</strong>ï¼ˆ$|p_i| < 1$ï¼‰</li>
            </ul>
        </div>
    </div>

    <script>
        // Canvasè®¾ç½®
        const zPlaneCanvas = document.getElementById('zPlaneCanvas');
        const freqCanvas = document.getElementById('freqResponseCanvas');
        const zCtx = zPlaneCanvas.getContext('2d');
        const fCtx = freqCanvas.getContext('2d');

        // ç³»ç»ŸçŠ¶æ€
        let zeros = [];
        let poles = [];
        let mode = null; // 'zero' or 'pole'
        let draggedPoint = null;
        let gain = 1.0;

        // å¸¸é‡
        const CENTER_X = 250;
        const CENTER_Y = 250;
        
        // --- MODIFICATION START ---
        // ä¿®æ”¹zå¹³é¢æ˜¾ç¤ºèŒƒå›´ä¸º -5 åˆ° 5
        const Z_MAX = 5; // å®šä¹‰Zå¹³é¢çš„æœ€å¤§åæ ‡å€¼
        // RADIUSç°åœ¨ä»£è¡¨zå¹³é¢ä¸Š"1ä¸ªå•ä½"å¯¹åº”çš„åƒç´ æ•°
        const RADIUS = CENTER_X / Z_MAX; // 250px / 5 units = 50px per unit
        // --- MODIFICATION END ---
        
        const POINT_RADIUS = 8;

        // åˆå§‹åŒ–
        function init() {
            drawZPlane();
            drawFrequencyResponse();
            setupEventListeners();
            
            // åˆå§‹æ¸²æŸ“MathJax
            if (window.MathJax) {
                MathJax.typesetPromise().catch((err) => console.log(err));
            }
        }

        // --- MODIFICATION START ---
        // é‡å†™ drawZPlane å‡½æ•°ä»¥é€‚åº”æ–°çš„ -5 åˆ° 5 èŒƒå›´
        function drawZPlane() {
            zCtx.clearRect(0, 0, 500, 500);
            
            // ç»˜åˆ¶ç½‘æ ¼
            zCtx.strokeStyle = '#e0e0e0';
            zCtx.lineWidth = 1;
            // å¾ªç¯ç»˜åˆ¶ä» -Z_MAX åˆ° Z_MAX çš„ç½‘æ ¼çº¿
            for (let i = -Z_MAX; i <= Z_MAX; i++) {
                if (i === 0) continue; // åæ ‡è½´ä¼šå¦å¤–åŠ ç²—ç»˜åˆ¶
                // å‚ç›´çº¿
                zCtx.beginPath();
                zCtx.moveTo(CENTER_X + i * RADIUS, 0);
                zCtx.lineTo(CENTER_X + i * RADIUS, 500);
                zCtx.stroke();
                // æ°´å¹³çº¿
                zCtx.beginPath();
                zCtx.moveTo(0, CENTER_Y + i * RADIUS);
                zCtx.lineTo(500, CENTER_Y + i * RADIUS);
                zCtx.stroke();
            }

            // ç»˜åˆ¶åæ ‡è½´
            zCtx.strokeStyle = '#333';
            zCtx.lineWidth = 2;
            // xè½´
            zCtx.beginPath();
            zCtx.moveTo(0, CENTER_Y);
            zCtx.lineTo(500, CENTER_Y);
            zCtx.stroke();
            // yè½´
            zCtx.beginPath();
            zCtx.moveTo(CENTER_X, 0);
            zCtx.lineTo(CENTER_X, 500);
            zCtx.stroke();

            // ç»˜åˆ¶å•ä½åœ†
            zCtx.strokeStyle = '#3498db';
            zCtx.lineWidth = 3;
            zCtx.beginPath();
            // å•ä½åœ†çš„åŠå¾„ç°åœ¨æ˜¯ 1 * RADIUS
            zCtx.arc(CENTER_X, CENTER_Y, 1 * RADIUS, 0, 2 * Math.PI);
            zCtx.stroke();

            // æ ‡æ³¨
            zCtx.fillStyle = '#333';
            zCtx.font = '14px Arial';
            zCtx.fillText('Re', 480, CENTER_Y - 10);
            zCtx.fillText('Im', CENTER_X + 10, 20);
            
            // æ›´æ–°åæ ‡è½´æ ‡ç­¾ä»¥é€‚åº”æ–°èŒƒå›´
            zCtx.textAlign = 'center';
            zCtx.textBaseline = 'top';
            zCtx.fillText('1', CENTER_X + 1 * RADIUS, CENTER_Y + 5);
            zCtx.fillText(Z_MAX.toString(), CENTER_X + Z_MAX * RADIUS - 10, CENTER_Y + 5);
            
            zCtx.textAlign = 'right';
            zCtx.textBaseline = 'middle';
            zCtx.fillText('-1', CENTER_X - 1 * RADIUS, CENTER_Y - 10);
            zCtx.fillText((-Z_MAX).toString(), CENTER_X - Z_MAX * RADIUS + 25, CENTER_Y - 10);
            
            zCtx.textAlign = 'left';
            zCtx.textBaseline = 'middle';
            zCtx.fillText(Z_MAX.toString() + 'j', CENTER_X + 5, CENTER_Y - Z_MAX * RADIUS + 10);
            zCtx.fillText((-Z_MAX).toString() + 'j', CENTER_X + 5, CENTER_Y + Z_MAX * RADIUS - 10);


            // ç»˜åˆ¶é›¶ç‚¹ (æ­¤éƒ¨åˆ†ä»£ç æ— éœ€ä¿®æ”¹)
            zeros.forEach((z, idx) => {
                const x = CENTER_X + z.real * RADIUS;
                const y = CENTER_Y - z.imag * RADIUS;
                
                zCtx.strokeStyle = '#3498db';
                zCtx.fillStyle = 'white';
                zCtx.lineWidth = 3;
                zCtx.beginPath();
                zCtx.arc(x, y, POINT_RADIUS, 0, 2 * Math.PI);
                zCtx.fill();
                zCtx.stroke();
                
                if (z.multiplicity && z.multiplicity > 1) {
                    zCtx.fillStyle = '#3498db';
                    zCtx.font = 'bold 12px Arial';
                    zCtx.fillText(z.multiplicity.toString(), x + 12, y - 8);
                }
            });

            // ç»˜åˆ¶æç‚¹ (æ­¤éƒ¨åˆ†ä»£ç æ— éœ€ä¿®æ”¹)
            poles.forEach((p, idx) => {
                const x = CENTER_X + p.real * RADIUS;
                const y = CENTER_Y - p.imag * RADIUS;
                
                zCtx.strokeStyle = '#e74c3c';
                zCtx.lineWidth = 3;
                zCtx.beginPath();
                zCtx.moveTo(x - POINT_RADIUS, y - POINT_RADIUS);
                zCtx.lineTo(x + POINT_RADIUS, y + POINT_RADIUS);
                zCtx.moveTo(x + POINT_RADIUS, y - POINT_RADIUS);
                zCtx.lineTo(x - POINT_RADIUS, y + POINT_RADIUS);
                zCtx.stroke();
                
                if (p.multiplicity && p.multiplicity > 1) {
                    zCtx.fillStyle = '#e74c3c';
                    zCtx.font = 'bold 12px Arial';
                    zCtx.fillText(p.multiplicity.toString(), x + 12, y - 8);
                }
            });

            updateStats();
        }
        // --- MODIFICATION END ---

        // è®¡ç®—å¹¶ç»˜åˆ¶é¢‘ç‡å“åº”
        function drawFrequencyResponse() {
            fCtx.clearRect(0, 0, 500, 500);

            const width = 500;
            const height = 500;
            const padding = 50;
            const plotWidth = width - 2 * padding;
            const plotHeight = height - 2 * padding;

            // è®¡ç®—é¢‘ç‡å“åº”
            const numPoints = 512;
            let magnitudes = [];
            let maxMag = 0;

            for (let i = 0; i < numPoints; i++) {
                const omega = (i / numPoints) * Math.PI * 2;
                const z_real = Math.cos(omega);
                const z_imag = Math.sin(omega);
                
                const mag = calculateMagnitude(z_real, z_imag);
                magnitudes.push(mag);
                if (mag > maxMag && mag < 100) maxMag = mag;
            }

            // è‡ªåŠ¨è°ƒæ•´yè½´èŒƒå›´
            const yMax = Math.min(maxMag * 1.2, 20);

            // ç»˜åˆ¶åæ ‡è½´
            fCtx.strokeStyle = '#333';
            fCtx.lineWidth = 2;
            fCtx.beginPath();
            fCtx.moveTo(padding, height - padding);
            fCtx.lineTo(width - padding, height - padding);
            fCtx.lineTo(width - padding, padding);
            fCtx.stroke();

            // ç»˜åˆ¶ç½‘æ ¼å’Œåˆ»åº¦
            fCtx.strokeStyle = '#e0e0e0';
            fCtx.lineWidth = 1;
            fCtx.fillStyle = '#666';
            fCtx.font = '12px Arial';

            // yè½´ç½‘æ ¼
            for (let i = 0; i <= 5; i++) {
                const y = height - padding - (i / 5) * plotHeight;
                fCtx.beginPath();
                fCtx.moveTo(padding, y);
                fCtx.lineTo(width - padding, y);
                fCtx.stroke();
                
                const label = (yMax * i / 5).toFixed(1);
                fCtx.fillText(label, padding - 35, y + 5);
            }

            // xè½´ç½‘æ ¼å’Œæ ‡ç­¾
            const freqLabels = ['0', 'Ï€/4', 'Ï€/2', '3Ï€/4', 'Ï€', '5Ï€/4', '3Ï€/2', '7Ï€/4', '2Ï€'];
            fCtx.font = '12px Arial';
            for (let i = 0; i <= 8; i++) {
                const x = padding + (i / 8) * plotWidth;
                fCtx.beginPath();
                fCtx.moveTo(x, padding);
                fCtx.lineTo(x, height - padding);
                fCtx.stroke();
                
                // ç»˜åˆ¶åˆ»åº¦æ ‡ç­¾
                fCtx.save();
                fCtx.translate(x, height - padding + 20);
                fCtx.textAlign = 'center';
                fCtx.fillText(freqLabels[i], 0, 0);
                fCtx.restore();
            }

            // æ ‡ç­¾
            fCtx.fillStyle = '#333';
            fCtx.font = 'bold 16px Arial';
            fCtx.fillText('|H(e^jÏ‰)|', 10, 30);
            fCtx.font = 'bold 14px Arial';
            fCtx.fillText('Ï‰ (å¼§åº¦)', width - 90, height - 10);

            // ç»˜åˆ¶é¢‘ç‡å“åº”æ›²çº¿
            fCtx.strokeStyle = '#e74c3c';
            fCtx.lineWidth = 3;
            fCtx.beginPath();
            
            for (let i = 0; i < numPoints; i++) {
                const x = padding + (i / numPoints) * plotWidth;
                const mag = Math.min(magnitudes[i], yMax);
                const y = height - padding - (mag / yMax) * plotHeight;
                
                if (i === 0) {
                    fCtx.moveTo(x, y);
                } else {
                    fCtx.lineTo(x, y);
                }
            }
            fCtx.stroke();

            // å¡«å……æ›²çº¿ä¸‹æ–¹åŒºåŸŸ
            fCtx.fillStyle = 'rgba(231, 76, 60, 0.1)';
            fCtx.lineTo(width - padding, height - padding);
            fCtx.lineTo(padding, height - padding);
            fCtx.closePath();
            fCtx.fill();

            updateSystemInfo();
        }

        // è®¡ç®—æŸç‚¹çš„å¹…åº¦å“åº”
        function calculateMagnitude(z_real, z_imag) {
            if (zeros.length === 0 && poles.length === 0) {
                return 1.0;
            }

            let numerator = gain;
            let denominator = 1.0;

            // è®¡ç®—åˆ°æ‰€æœ‰é›¶ç‚¹çš„è·ç¦»
            zeros.forEach(zero => {
                const mult = zero.multiplicity || 1;
                for (let i = 0; i < mult; i++) {
                    const dist = Math.sqrt(
                        Math.pow(z_real - zero.real, 2) + 
                        Math.pow(z_imag - zero.imag, 2)
                    );
                    numerator *= dist;
                }
            });

            // è®¡ç®—åˆ°æ‰€æœ‰æç‚¹çš„è·ç¦»
            poles.forEach(pole => {
                const mult = pole.multiplicity || 1;
                for (let i = 0; i < mult; i++) {
                    const dist = Math.sqrt(
                        Math.pow(z_real - pole.real, 2) + 
                        Math.pow(z_imag - pole.imag, 2)
                    );
                    denominator *= dist;
                }
            });

            return denominator !== 0 ? numerator / denominator : 100;
        }

        // äº‹ä»¶ç›‘å¬
        function setupEventListeners() {
            zPlaneCanvas.addEventListener('click', handleCanvasClick);
            zPlaneCanvas.addEventListener('mousedown', handleMouseDown);
            zPlaneCanvas.addEventListener('mousemove', handleMouseMove);
            zPlaneCanvas.addEventListener('mouseup', handleMouseUp);
            zPlaneCanvas.addEventListener('dblclick', handleDoubleClick);
        }

        function handleCanvasClick(e) {
            if (mode === null) return;

            const rect = zPlaneCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const real = (x - CENTER_X) / RADIUS;
            const imag = (CENTER_Y - y) / RADIUS;

            const point = { real, imag, multiplicity: 1 };

            if (mode === 'zero') {
                // æ£€æŸ¥æ˜¯å¦ä¸ç°æœ‰é›¶ç‚¹é‡åˆ
                const existing = findNearbyPoint(zeros, real, imag, 0.05);
                if (existing) {
                    existing.multiplicity = (existing.multiplicity || 1) + 1;
                } else {
                    zeros.push(point);
                }
            } else if (mode === 'pole') {
                // æ£€æŸ¥æ˜¯å¦ä¸ç°æœ‰æç‚¹é‡åˆ
                const existing = findNearbyPoint(poles, real, imag, 0.05);
                if (existing) {
                    existing.multiplicity = (existing.multiplicity || 1) + 1;
                } else {
                    poles.push(point);
                }
            }

            drawZPlane();
            drawFrequencyResponse();
        }

        function findNearbyPoint(points, real, imag, threshold) {
            return points.find(p => 
                Math.sqrt(Math.pow(p.real - real, 2) + Math.pow(p.imag - imag, 2)) < threshold
            );
        }

        function handleMouseDown(e) {
            const rect = zPlaneCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const real = (x - CENTER_X) / RADIUS;
            const imag = (CENTER_Y - y) / RADIUS;

            // æŸ¥æ‰¾æœ€è¿‘çš„ç‚¹
            let minDist = 0.1 * (5 / Z_MAX); // è°ƒæ•´æ‹–åŠ¨çµæ•åº¦ä»¥é€‚åº”æ–°ç¼©æ”¾
            let nearestPoint = null;
            let pointType = null;

            zeros.forEach(z => {
                const dist = Math.sqrt(Math.pow(z.real - real, 2) + Math.pow(z.imag - imag, 2));
                if (dist < minDist) {
                    minDist = dist;
                    nearestPoint = z;
                    pointType = 'zero';
                }
            });

            poles.forEach(p => {
                const dist = Math.sqrt(Math.pow(p.real - real, 2) + Math.pow(p.imag - imag, 2));
                if (dist < minDist) {
                    minDist = dist;
                    nearestPoint = p;
                    pointType = 'pole';
                }
            });

            if (nearestPoint) {
                draggedPoint = { point: nearestPoint, type: pointType };
                mode = null; // å–æ¶ˆæ·»åŠ æ¨¡å¼
            }
        }

        function handleMouseMove(e) {
            if (!draggedPoint) return;

            const rect = zPlaneCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            draggedPoint.point.real = (x - CENTER_X) / RADIUS;
            draggedPoint.point.imag = (CENTER_Y - y) / RADIUS;

            // é™åˆ¶åœ¨åˆç†èŒƒå›´å†…
            draggedPoint.point.real = Math.max(-Z_MAX, Math.min(Z_MAX, draggedPoint.point.real));
            draggedPoint.point.imag = Math.max(-Z_MAX, Math.min(Z_MAX, draggedPoint.point.imag));

            drawZPlane();
            drawFrequencyResponse();
        }

        function handleMouseUp(e) {
            draggedPoint = null;
        }

        function handleDoubleClick(e) {
            const rect = zPlaneCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const real = (x - CENTER_X) / RADIUS;
            const imag = (CENTER_Y - y) / RADIUS;

            // åˆ é™¤æœ€è¿‘çš„ç‚¹
            let minDist = 0.1 * (5 / Z_MAX); // è°ƒæ•´åŒå‡»çµæ•åº¦ä»¥é€‚åº”æ–°ç¼©æ”¾
            let deleteIndex = -1;
            let deleteType = null;

            zeros.forEach((z, idx) => {
                const dist = Math.sqrt(Math.pow(z.real - real, 2) + Math.pow(z.imag - imag, 2));
                if (dist < minDist) {
                    minDist = dist;
                    deleteIndex = idx;
                    deleteType = 'zero';
                }
            });

            poles.forEach((p, idx) => {
                const dist = Math.sqrt(Math.pow(p.real - real, 2) + Math.pow(p.imag - imag, 2));
                if (dist < minDist) {
                    minDist = dist;
                    deleteIndex = idx;
                    deleteType = 'pole';
                }
            });

            if (deleteIndex >= 0) {
                if (deleteType === 'zero') {
                    if (zeros[deleteIndex].multiplicity > 1) {
                        zeros[deleteIndex].multiplicity--;
                    } else {
                        zeros.splice(deleteIndex, 1);
                    }
                } else {
                    if (poles[deleteIndex].multiplicity > 1) {
                        poles[deleteIndex].multiplicity--;
                    } else {
                        poles.splice(deleteIndex, 1);
                    }
                }
                drawZPlane();
                drawFrequencyResponse();
            }
        }

        // æ§åˆ¶å‡½æ•°
        function setMode(m) {
            mode = m;
            const buttons = document.querySelectorAll('.btn-zero, .btn-pole');
            buttons.forEach(btn => btn.style.opacity = '0.6');
            
            if (m === 'zero') {
                document.querySelector('.btn-zero').style.opacity = '1';
            } else if (m === 'pole') {
                document.querySelector('.btn-pole').style.opacity = '1';
            }
        }

        function clearAll() {
            zeros = [];
            poles = [];
            mode = null;
            drawZPlane();
            drawFrequencyResponse();
            
            const buttons = document.querySelectorAll('.btn-zero, .btn-pole');
            buttons.forEach(btn => btn.style.opacity = '0.6');
        }

        function updateStats() {
            let zeroCount = 0;
            zeros.forEach(z => zeroCount += (z.multiplicity || 1));
            let poleCount = 0;
            poles.forEach(p => poleCount += (p.multiplicity || 1));
            
            document.getElementById('zeroCount').textContent = zeroCount;
            document.getElementById('poleCount').textContent = poleCount;
        }

        function updateSystemInfo() {
            const info = document.getElementById('systemInfo');
            
            if (zeros.length === 0 && poles.length === 0) {
                info.innerHTML = 'ç­‰å¾…æ·»åŠ é›¶æç‚¹...';
                return;
            }

            let html = '<strong>ç³»ç»Ÿé…ç½®ï¼š</strong><br><br>';
            
            // æ˜¾ç¤ºç³»ç»Ÿå‡½æ•°å½¢å¼
            let zeroCount = 0;
            zeros.forEach(z => zeroCount += (z.multiplicity || 1));
            let poleCount = 0;
            poles.forEach(p => poleCount += (p.multiplicity || 1));
            
            html += `<strong>ç³»ç»Ÿå‡½æ•°:</strong> $H(z) = K \\frac{`;
            if (zeroCount > 0) {
                html += `\\prod_{i=1}^{${zeroCount}}(z-z_i)`;
            } else {
                html += '1';
            }
            html += `}{`;
            if (poleCount > 0) {
                html += `\\prod_{j=1}^{${poleCount}}(z-p_j)`;
            } else {
                html += '1';
            }
            html += `}$<br><br>`;
            
            if (zeros.length > 0) {
                html += '<strong>é›¶ç‚¹ (Zeros):</strong><br>';
                zeros.forEach((z, idx) => {
                    const mult = z.multiplicity > 1 ? ` <span style="color: #3498db;">(${z.multiplicity}é‡)</span>` : '';
                    const sign = z.imag >= 0 ? '+' : '';
                    html += `&nbsp;&nbsp;$z_{${idx+1}} = ${z.real.toFixed(3)} ${sign} ${z.imag.toFixed(3)}j$ ${mult}<br>`;
                });
            }
            
            if (poles.length > 0) {
                html += '<br><strong>æç‚¹ (Poles):</strong><br>';
                poles.forEach((p, idx) => {
                    const mult = p.multiplicity > 1 ? ` <span style="color: #e74c3c;">(${p.multiplicity}é‡)</span>` : '';
                    const sign = p.imag >= 0 ? '+' : '';
                    const mag = Math.sqrt(p.real * p.real + p.imag * p.imag);
                    html += `&nbsp;&nbsp;$p_{${idx+1}} = ${p.real.toFixed(3)} ${sign} ${p.imag.toFixed(3)}j$ ${mult}`;
                    html += ` &nbsp; $|p_{${idx+1}}| = ${mag.toFixed(3)}$<br>`;
                });
            }

            // åˆ¤æ–­ç¨³å®šæ€§
            const stable = poles.every(p => {
                const mag = Math.sqrt(p.real * p.real + p.imag * p.imag);
                return mag < 1.0;
            });
            
            html += `<br><strong>ç³»ç»Ÿç¨³å®šæ€§:</strong> `;
            if (poles.length === 0) {
                html += '<span style="color: #27ae60;">âœ“ ç¨³å®š</span> (FIRç³»ç»Ÿï¼Œæ— æç‚¹)';
            } else if (stable) {
                html += '<span style="color: #27ae60;">âœ“ ç¨³å®š</span> (æ‰€æœ‰æç‚¹æ»¡è¶³ $|p_j| < 1$)';
            } else {
                html += '<span style="color: #e74c3c;">âœ— ä¸ç¨³å®š</span> (å­˜åœ¨æç‚¹ $|p_j| \\geq 1$)';
            }
            
            info.innerHTML = html;
            
            // é‡æ–°æ¸²æŸ“MathJax
            if (window.MathJax) {
                MathJax.typesetPromise([info]).catch((err) => console.log(err));
            }
        }

        // é¢„è®¾é…ç½®
        function loadPreset(type) {
            clearAll();
            
            switch(type) {
                case 'lowpass':
                    // ä½é€šæ»¤æ³¢å™¨: é›¶ç‚¹åœ¨ z=-1 (Ï‰=Ï€), æç‚¹åœ¨ z=0.6
                    zeros.push({ real: -1, imag: 0, multiplicity: 1 });
                    poles.push({ real: 0.6, imag: 0, multiplicity: 1 });
                    break;
                    
                case 'highpass':
                    // é«˜é€šæ»¤æ³¢å™¨: é›¶ç‚¹åœ¨ z=1 (Ï‰=0), æç‚¹åœ¨ z=-0.6
                    zeros.push({ real: 1, imag: 0, multiplicity: 1 });
                    poles.push({ real: -0.6, imag: 0, multiplicity: 1 });
                    break;
                    
                case 'bandpass':
                    // å¸¦é€šæ»¤æ³¢å™¨: é›¶ç‚¹åœ¨ z=Â±1, æç‚¹ä¸ºå…±è½­å¯¹ z=0.8e^(Â±jÏ€/3)
                    zeros.push({ real: 1, imag: 0, multiplicity: 1 });
                    zeros.push({ real: -1, imag: 0, multiplicity: 1 });
                    const angle = Math.PI / 3;
                    poles.push({ real: 0.8 * Math.cos(angle), imag: 0.8 * Math.sin(angle), multiplicity: 1 });
                    poles.push({ real: 0.8 * Math.cos(angle), imag: -0.8 * Math.sin(angle), multiplicity: 1 });
                    break;
                    
                case 'notch':
                    // é™·æ³¢æ»¤æ³¢å™¨: é›¶ç‚¹åœ¨å•ä½åœ†ä¸Š z=e^(Â±jÏ€/2)ï¼Œæç‚¹åœ¨åŒè§’åº¦ä½† r=0.9
                    const notchAngle = Math.PI / 2;
                    zeros.push({ real: Math.cos(notchAngle), imag: Math.sin(notchAngle), multiplicity: 1 });
                    zeros.push({ real: Math.cos(notchAngle), imag: -Math.sin(notchAngle), multiplicity: 1 });
                    poles.push({ real: 0.9 * Math.cos(notchAngle), imag: 0.9 * Math.sin(notchAngle), multiplicity: 1 });
                    poles.push({ real: 0.9 * Math.cos(notchAngle), imag: -0.9 * Math.sin(notchAngle), multiplicity: 1 });
                    break;
                    
                case 'resonator':
                    // è°æŒ¯å™¨: å…±è½­æç‚¹å¯¹éå¸¸æ¥è¿‘å•ä½åœ† z=0.95e^(Â±jÏ€/4)
                    const resAngle = Math.PI / 4;
                    poles.push({ real: 0.95 * Math.cos(resAngle), imag: 0.95 * Math.sin(resAngle), multiplicity: 1 });
                    poles.push({ real: 0.95 * Math.cos(resAngle), imag: -0.95 * Math.sin(resAngle), multiplicity: 1 });
                    break;
                    
                case 'multiple':
                    // å¤šé›¶æç‚¹ç³»ç»Ÿ
                    zeros.push({ real: 0.5, imag: 0.5, multiplicity: 1 });
                    zeros.push({ real: 0.5, imag: -0.5, multiplicity: 1 });
                    zeros.push({ real: -0.7, imag: 0, multiplicity: 1 });
                    poles.push({ real: 0.3, imag: 0.3, multiplicity: 1 });
                    poles.push({ real: 0.3, imag: -0.3, multiplicity: 1 });
                    break;
                    
                case 'repeated':
                    // é‡é›¶æç‚¹: ä¸‰é‡é›¶ç‚¹åœ¨ z=-0.5, äºŒé‡æç‚¹åœ¨ z=0.4
                    zeros.push({ real: -0.5, imag: 0, multiplicity: 3 });
                    poles.push({ real: 0.4, imag: 0, multiplicity: 2 });
                    break;
            }
            
            drawZPlane();
            drawFrequencyResponse();
        }

        // åˆå§‹åŒ–åº”ç”¨
        init();
    </script>
</body>
</html>